<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>精炼23种设计模式 | mmzsblog</title>
  <meta name="description" content="[toc] 一、创建型 工厂模式简单工厂模式以继承的思想分别生产不同的产品。例：123456789101112131415161718192021222324252627282930public interface CPU()&amp;#123;	void createCPU();&amp;#125;public class IntelCPU implements CPU&amp;#123;		@Override	pub">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="精炼23种设计模式">
<meta property="og:url" content="https://blog.mmzsblog.cn/Design-Patterns/designPatterns/index.html">
<meta property="og:site_name" content="mmzsblog">
<meta property="og:description" content="[toc] 一、创建型 工厂模式简单工厂模式以继承的思想分别生产不同的产品。例：123456789101112131415161718192021222324252627282930public interface CPU()&amp;#123;	void createCPU();&amp;#125;public class IntelCPU implements CPU&amp;#123;		@Override	pub">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-14T03:35:46.325Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="精炼23种设计模式">
<meta name="twitter:description" content="[toc] 一、创建型 工厂模式简单工厂模式以继承的思想分别生产不同的产品。例：123456789101112131415161718192021222324252627282930public interface CPU()&amp;#123;	void createCPU();&amp;#125;public class IntelCPU implements CPU&amp;#123;		@Override	pub">
  <!-- Canonical links -->
  <link rel="canonical" href="https://blog.mmzsblog.cn/Design-Patterns/designPatterns/index.html">
  
    <link rel="alternate" href="/atom.xml" title="mmzsblog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/mmzsblog" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">mmzsblog</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Java Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> ChengDu, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech="">
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope="" itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archive">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/mmzsblog" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>感谢光临本博客网站，本博客将持续更新技术帖，你也可关注微信公众号，第一时间收到最新文章</p><div class="text-center"><img src="/images/weChat.jpg" width="169px"></div>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Design-Patterns/">Design Patterns</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Development-Tools/">Development Tools</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2ee/">J2ee</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Program-Life/">Program Life</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mmzs/">mmzs</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/springboot/">springboot</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/JVM虚拟机/" style="font-size: 14px;">JVM虚拟机</a> <a href="/tags/Java/" style="font-size: 13.5px;">Java</a> <a href="/tags/git/" style="font-size: 13px;">git</a> <a href="/tags/hexo/" style="font-size: 13px;">hexo</a> <a href="/tags/idea/" style="font-size: 13px;">idea</a> <a href="/tags/mmzs/" style="font-size: 13px;">mmzs</a> <a href="/tags/npm/" style="font-size: 13px;">npm</a> <a href="/tags/springboot/" style="font-size: 13px;">springboot</a> <a href="/tags/加密算法/" style="font-size: 13px;">加密算法</a> <a href="/tags/年终总结/" style="font-size: 13px;">年终总结</a> <a href="/tags/框架/" style="font-size: 13px;">框架</a> <a href="/tags/注解/" style="font-size: 13px;">注解</a> <a href="/tags/编程语言/" style="font-size: 13px;">编程语言</a> <a href="/tags/设计模式/" style="font-size: 13px;">设计模式</a> <a href="/tags/集合/" style="font-size: 13px;">集合</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archive/2019/02/">二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2019/01/">一月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2018/12/">十二月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2018/10/">十月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2017/08/">八月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2016/10/">十月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2014/11/">十一月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2013/11/">十一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2012/11/">十一月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2011/10/">十月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2010/10/">十月 2010</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/mmzs/">mmzs</a>
              </p>
              <p class="item-title">
                <a href="/mmzs/addGoogleSitemap/" class="title">Hexo优化：创建sitemap站点地图并向google提交</a>
              </p>
              <p class="item-date">
                <time datetime="2019-02-14T03:15:33.000Z" itemprop="datePublished">2019-02-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Development-Tools/">Development Tools</a>
              </p>
              <p class="item-title">
                <a href="/Development-Tools/IDEA开发插件推荐/" class="title">IDEA开发插件推荐</a>
              </p>
              <p class="item-date">
                <time datetime="2019-01-09T04:55:04.000Z" itemprop="datePublished">2019-01-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java/">Java</a>
              </p>
              <p class="item-title">
                <a href="/Java/一文详解集合的不同之处/" class="title">一文详解集合的不同之处</a>
              </p>
              <p class="item-date">
                <time datetime="2019-01-04T04:40:48.000Z" itemprop="datePublished">2019-01-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Program-Life/">Program Life</a>
              </p>
              <p class="item-title">
                <a href="/Program-Life/2018年终总结/" class="title">2018年终总结</a>
              </p>
              <p class="item-date">
                <time datetime="2018-12-31T15:59:59.000Z" itemprop="datePublished">2018-12-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/springboot/">springboot</a>
              </p>
              <p class="item-title">
                <a href="/springboot/玩转SpringBoot之定时任务详解/" class="title">玩转SpringBoot之定时任务详解</a>
              </p>
              <p class="item-date">
                <time datetime="2018-12-21T07:13:29.000Z" itemprop="datePublished">2018-12-21</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc" id="collapseToc" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、创建型"><span class="toc-number">1.</span> <span class="toc-text">一、创建型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式"><span class="toc-number">1.1.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单工厂模式"><span class="toc-number">1.1.1.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">1.1.2.</span> <span class="toc-text">抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">1.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建造者模式"><span class="toc-number">1.3.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-number">1.4.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-number">1.5.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#懒汉模式"><span class="toc-number">1.5.1.</span> <span class="toc-text">懒汉模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#饿汉模式"><span class="toc-number">1.5.2.</span> <span class="toc-text">饿汉模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双重检查加锁"><span class="toc-number">1.5.3.</span> <span class="toc-text">双重检查加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lazy-initialization-holder-class模式"><span class="toc-number">1.5.4.</span> <span class="toc-text">Lazy initialization holder class模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、结构型"><span class="toc-number">2.</span> <span class="toc-text">二、结构型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#适配器模式"><span class="toc-number">2.1.</span> <span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类适配器模式"><span class="toc-number">2.1.1.</span> <span class="toc-text">类适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象适配器模式"><span class="toc-number">2.1.2.</span> <span class="toc-text">对象适配器模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰者模式"><span class="toc-number">2.2.</span> <span class="toc-text">装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#透明装饰模式"><span class="toc-number">2.2.1.</span> <span class="toc-text">透明装饰模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#半透明装饰模式"><span class="toc-number">2.2.2.</span> <span class="toc-text">半透明装饰模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式（做对比）"><span class="toc-number">2.2.3.</span> <span class="toc-text">适配器模式（做对比）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桥接模式"><span class="toc-number">2.3.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合模式"><span class="toc-number">2.4.</span> <span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安全式"><span class="toc-number">2.4.1.</span> <span class="toc-text">安全式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#透明式"><span class="toc-number">2.4.2.</span> <span class="toc-text">透明式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外观模式-Facade"><span class="toc-number">2.5.</span> <span class="toc-text">外观模式(Facade)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#享元模式"><span class="toc-number">2.6.</span> <span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单纯享元模式：共享对象"><span class="toc-number">2.6.1.</span> <span class="toc-text">单纯享元模式：共享对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂享元模式"><span class="toc-number">2.6.2.</span> <span class="toc-text">复杂享元模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理模式"><span class="toc-number">2.7.</span> <span class="toc-text">代理模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、-行为型"><span class="toc-number">3.</span> <span class="toc-text">三、 行为型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#责任链模式"><span class="toc-number">3.1.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命令模式"><span class="toc-number">3.2.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释器模式"><span class="toc-number">3.3.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中介者模式"><span class="toc-number">3.4.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代模式（Cursor）"><span class="toc-number">3.5.</span> <span class="toc-text">迭代模式（Cursor）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#观察者模式"><span class="toc-number">3.6.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#策略模式"><span class="toc-number">3.7.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板方法模式"><span class="toc-number">3.8.</span> <span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问者模式"><span class="toc-number">3.9.</span> <span class="toc-text">访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态分派"><span class="toc-number">3.9.1.</span> <span class="toc-text">静态分派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分派"><span class="toc-number">3.9.2.</span> <span class="toc-text">动态分派</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#备忘录模式"><span class="toc-number">3.10.</span> <span class="toc-text">备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#白箱备忘录模式"><span class="toc-number">3.10.1.</span> <span class="toc-text">白箱备忘录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#黑箱备忘录模式"><span class="toc-number">3.10.2.</span> <span class="toc-text">黑箱备忘录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重检查点"><span class="toc-number">3.10.3.</span> <span class="toc-text">多重检查点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态模式"><span class="toc-number">3.11.</span> <span class="toc-text">状态模式</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-designPatterns" class="article article-type-post" itemscope="" itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      精炼23种设计模式
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/Design-Patterns/designPatterns/" class="article-date">
	  <time datetime="2011-10-24T02:24:00.000Z" itemprop="datePublished">2011-10-24</time>
	</a>
</span>
	
<span class="article-user">
    <i class="icon icon-code"></i>

    老王和小杨

</span>

        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Design-Patterns/">Design Patterns</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/设计模式/">设计模式</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/Design-Patterns/designPatterns/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.9k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 50(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="一、创建型"><a href="#一、创建型" class="headerlink" title="一、创建型"></a>一、创建型</h1><hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>以继承的思想分别生产不同的产品。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface CPU()&#123;</span><br><span class="line">	void createCPU();</span><br><span class="line">&#125;</span><br><span class="line">public class IntelCPU implements CPU&#123;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void createCPU()&#123;</span><br><span class="line">		//具体实现</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AMDCPU implements CPU&#123;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void createCPU()&#123;</span><br><span class="line">		//具体实现</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//工厂</span><br><span class="line">public class CPUFactory&#123;</span><br><span class="line">	public void createCPU(int cpuType)&#123;</span><br><span class="line">	CPU cpu = null;</span><br><span class="line">		if(cpuType == 1 )&#123;</span><br><span class="line">			cpu = new IntelCPU(); //生产IntelCPU，实现细节略。</span><br><span class="line">		&#125;else if(cpuType == 2 )&#123;</span><br><span class="line">			cpu = new AMDCPU(); //生产AMD CPU ，实现细节略。</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>以继承+归类的思想分别生产不同的产品。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface Factory&#123;</span><br><span class="line">	CPU createCPU();</span><br><span class="line">	MainBoard createMainBoard();</span><br><span class="line">&#125;</span><br><span class="line">public class IntelFactory implements Factory&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public CPU createCPU()&#123;</span><br><span class="line">		return new IntelCPU();</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public MainBoard createCPU()&#123;</span><br><span class="line">		return new IntelMainBoard();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class AMDFactory implements Factory&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public CPU createCPU()&#123;</span><br><span class="line">		return new AMDCPU();</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public MainBoard createCPU()&#123;</span><br><span class="line">		return new AMDMainBoard();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在抽象工厂模式的基础上，更加复杂化子类，让子类再归类，然后再生产不同的产品。<br><br>例：将文件导出为指定形式（html和pdf，但是还要配合具体的部门，比如标准的输出、财务的输出等），如何设计？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public interface ExportFactory&#123;</span><br><span class="line">	ExportFile factorty(String type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExportHtmlFactory implements Factory&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public ExportFile factorty(String type)&#123;</span><br><span class="line">		if(&quot;standard&quot;.equals(type))&#123;</span><br><span class="line">			return new ExportStandardHtmlFile();</span><br><span class="line">		&#125;else if(&quot;financial&quot;.equals(type))&#123;</span><br><span class="line">			return new ExportFinancialHtmlFile();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			throw new Exception(&quot;未找到&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExportPDFFactory implements Factory&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public ExportFile factorty(String type)&#123;</span><br><span class="line">		if(&quot;standard&quot;.equals(type))&#123;</span><br><span class="line">			return new ExportStandardPDFFile();</span><br><span class="line">		&#125;else if(&quot;financial&quot;.equals(type))&#123;</span><br><span class="line">			return new ExportFinancialPDFFile();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			throw new Exception(&quot;未找到&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface ExportFile&#123;</span><br><span class="line">	public boolean export(String data);</span><br><span class="line">&#125; </span><br><span class="line">public class ExportStandardHtmlFile implements ExportFile&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean export(String data)&#123;</span><br><span class="line">		//业务逻辑</span><br><span class="line">		System.out.println(&quot;标准的HMTL输出&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExportFinancialHtmlFile implements ExportFile&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean export(String data)&#123;</span><br><span class="line">		//业务逻辑</span><br><span class="line">		System.out.println(&quot;财务的HMTL输出&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExportStandardPDFFile implements ExportFile&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean export(String data)&#123;</span><br><span class="line">		//业务逻辑</span><br><span class="line">		System.out.println(&quot;标准的PDF输出&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExportFinancialPDFFile implements ExportFile&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean export(String data)&#123;</span><br><span class="line">		//业务逻辑</span><br><span class="line">		System.out.println(&quot;财务的PDF输出&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		String data = &quot;&quot;;</span><br><span class="line">		ExportFactory exportFactory = new ExportHtmlFactory();</span><br><span class="line">		ExportFile ef = exportFactory.factory(&quot;financial&quot;);</span><br><span class="line">		ef.export(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分离，从而可以生成具有不同的内部表象的产品。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//产品</span><br><span class="line">public class Product()&#123;</span><br><span class="line">	private String part1;</span><br><span class="line">	private Strign part2;</span><br><span class="line">	//省略set/get</span><br><span class="line">&#125;</span><br><span class="line">//抽象建造者</span><br><span class="line">public interface Builder&#123;</span><br><span class="line">	void buildPart1();</span><br><span class="line">	void buildPart2();</span><br><span class="line">	Product retrieveResult();</span><br><span class="line">&#125;</span><br><span class="line">public class concreteBuilder implements Builder&#123;</span><br><span class="line">	private Product product = new Product();</span><br><span class="line">	@Override</span><br><span class="line">	public void buildPart1()&#123;</span><br><span class="line">		//生产第一部分</span><br><span class="line">	&#125;</span><br><span class="line">	public void buildPart2()&#123;</span><br><span class="line">		//生产第二部分</span><br><span class="line">	&#125;</span><br><span class="line">	public void retrieveResult()&#123;</span><br><span class="line">		return product;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Director &#123;</span><br><span class="line">	private Builder builder;</span><br><span class="line">	public Director(Builder builder)&#123;</span><br><span class="line">		this.builder = builder;</span><br><span class="line">	&#125;</span><br><span class="line">	public void construct()&#123;</span><br><span class="line">		this.builder.buildPart1();</span><br><span class="line">		this.builder.buildPart2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[]args)&#123;</span><br><span class="line">		Builder builder = new ConcreteBuilder();</span><br><span class="line">		Director director = new Director(builder);</span><br><span class="line">		director.construct();</span><br><span class="line">		Product product = builder.retrieveResult();</span><br><span class="line">		System.out.println(product.getPart1());</span><br><span class="line">		System.out.println(product.getPart2());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>给出一个原型对象来指明所创建的对象的类型，然后复制这个原型对象创建出更多同类型的对象。<br><br>|- 克隆：克隆的对象和原对象不是同一个对象，但是类型与原对象类型相同。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;|- 浅克隆： 所有的对其他对象的引用都仍然指向原来的对象，Object类的clone()方法默认是浅克隆。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;    |- 深度克隆：除了浅度克隆所要克隆的东西外，还要复制原对象所引用的对象。通常让对象实现Serializable接口，然后写入流（序列化），然后读出来（反序列化）。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object deepClone() throws Exception&#123;</span><br><span class="line">	//序列化，将对象写到流里</span><br><span class="line">	ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">	ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">	oos.writeObject(this);</span><br><span class="line">	//反序列化，从流里读出来</span><br><span class="line">	ByteArrayInputStream bis = new ByteArrayInputStream();</span><br><span class="line">	ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">	return ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//抽象原型角色</span><br><span class="line">public interface Prototype&#123;</span><br><span class="line">	//克隆自身的方法</span><br><span class="line">	public Object clone();</span><br><span class="line">&#125;</span><br><span class="line">//具体原型角色</span><br><span class="line">public class ConcretePrototype1 implements Prototype&#123;</span><br><span class="line">	public Prototype clone()&#123;</span><br><span class="line">		Prototype prototype = new ConcretePrototype1();</span><br><span class="line">		return prototype;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ConcretePrototype2 implements Prototype&#123;</span><br><span class="line">	public Prototype clone()&#123;</span><br><span class="line">		Prototype prototype = new ConcretePrototype2();</span><br><span class="line">		return prototype;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	private Prototype prototype;</span><br><span class="line">	pulic Client(Prototype prototype)&#123;</span><br><span class="line">		this.prototype = prototype;</span><br><span class="line">	&#125;</span><br><span class="line">	public void operation(Prototype example)&#123;</span><br><span class="line">		Prototype copy = prototype.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>确保某一个类只有一个实例，单例类需要想全局提供该类的实例。<br><br>|- 创建一个静态的私有单例类的实例。<br><br>|- 构造方法私有化，避免外界直接new该单例类。<br><br>|- 提供一个供外界访问的静态方法。<br></p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>需要的时候再new对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton instance = null;</span><br><span class="line">public static synchronized Singleton getInstance()&#123;</span><br><span class="line">	if(object == null)&#123;</span><br><span class="line">		instance = new xxx();</span><br><span class="line">	&#125;</span><br><span class="line">	return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>先new对象，等到需要再使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton instance =new xxx();</span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">	return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h3><p>|- 第一重检查：不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后先检查实例是否存在，如果不存在再进入下面的同步块。<br><br>|- 第二重检查：进入同步块后，再次检查实例是否存在，如果不存在，就在同步情况下创建一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private volatile static Singleton instance = null;</span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">	//先检查实例是否存在</span><br><span class="line">	if(instance == null)&#123;</span><br><span class="line">		//同步块，线程安全的创建实例</span><br><span class="line">		synchronized(Singleton.class)&#123;</span><br><span class="line">			//再次检查实例是否存在</span><br><span class="line">			if(instance == null)&#123;</span><br><span class="line">				instance = new Singleton();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Lazy-initialization-holder-class模式"><a href="#Lazy-initialization-holder-class模式" class="headerlink" title="Lazy initialization holder class模式"></a>Lazy initialization holder class模式</h3><p>综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。<br><br>|- 类级内部类：由static 修饰的内部类。<br><br>|- 多线程缺省同步锁的知识：在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。如：<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- 静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时<br><br>　&nbsp;&nbsp;&nbsp;&nbsp;　|- 访问final字段时<br><br>　&nbsp;&nbsp;&nbsp;&nbsp;　|- 在创建线程之前创建对象时<br><br>　&nbsp;&nbsp;&nbsp;&nbsp;　|- 线程可以看见它将要处理的对象时<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	private Singleton()&#123;&#125;</span><br><span class="line">	/**</span><br><span class="line">	 *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</span><br><span class="line">	 *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。</span><br><span class="line">	 */</span><br><span class="line">	private static class SingletonHolder&#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 静态初始化器，由JVM来保证线程安全</span><br><span class="line">		 */</span><br><span class="line">		private static Singleton instance = new Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		return SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>|- 枚举实现单例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 定义一个枚举的元素，它就代表了Singleton的一个实例。</span><br><span class="line">	 */</span><br><span class="line">	</span><br><span class="line">	uniqueInstance;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 单例可以有自己的操作</span><br><span class="line">	 */</span><br><span class="line">	public void singletonOperation()&#123;</span><br><span class="line">		//功能处理</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="二、结构型"><a href="#二、结构型" class="headerlink" title="二、结构型"></a>二、结构型</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>把一个接口转换成另一种接口从而能够匹配成客户端需要的接口。</p>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>把适配类的API转换成目标类的API。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Target&#123;</span><br><span class="line">	public void method1();</span><br><span class="line">	public void method2();</span><br><span class="line">&#125;</span><br><span class="line">public class Adaptee&#123;</span><br><span class="line">	public void method2();</span><br><span class="line">&#125;</span><br><span class="line">public class Adapter extends Adaptee implements Target&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void method1()&#123;</span><br><span class="line">		//实际代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//如上的Target和Adaptee</span><br><span class="line">public class Adapter&#123;</span><br><span class="line">	private Adaptee adaptee;</span><br><span class="line">	public Adapter(Adaptee adaptee)&#123;</span><br><span class="line">		this.adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	public void method1()&#123;</span><br><span class="line">		//实际代码</span><br><span class="line">	&#125;</span><br><span class="line">	public void method2()&#123;</span><br><span class="line">		this.adaptee.method2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>Wrapper模式，以对客户端透明的方式扩展对象的功能，是继承关系的一种替代。<br><br>|- 装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。<br><br>|- 允许装饰模式改变接口，增加新的方法。</p>
<h3 id="透明装饰模式"><a href="#透明装饰模式" class="headerlink" title="透明装饰模式"></a>透明装饰模式</h3><p>透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。</p>
<h3 id="半透明装饰模式"><a href="#半透明装饰模式" class="headerlink" title="半透明装饰模式"></a>半透明装饰模式</h3><p>装饰角色的接口与抽象构件角色接口不一致。<br><br>    例：Java中的I/O设计模式，就是典型的装饰模式。<br>    |- InputStream<br><br>&nbsp;&nbsp;&nbsp;&nbsp;|- ByteArrayInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;    |- FileInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;    |- FilterInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;        |- BufferedInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;        |- DataInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;        |- LineNumberInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;        |- PushbackInputStream<br> //典型的半透明装饰模式，因为它扩展了一个unread()方法，这个方法是抽象接口所没有的。<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;    |- ObjectInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;    |- PipedInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;    |- SquenceInputStream<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;    |- StringBufferInputStream<br></p>
<h3 id="适配器模式（做对比）"><a href="#适配器模式（做对比）" class="headerlink" title="适配器模式（做对比）"></a>适配器模式（做对比）</h3><p>半透明装饰模式是介于透明装饰模式和适配器模式之间的一种设计模式。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//抽象构件角色</span><br><span class="line">public interface Component&#123;</span><br><span class="line">	public void sampleOperation();</span><br><span class="line">&#125;</span><br><span class="line">//具体构件角色</span><br><span class="line">public class concreteComponent implements Component&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void sampleOperation()&#123;</span><br><span class="line">		//具体业务</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//装饰角色</span><br><span class="line">public class Decorator implements Component&#123;</span><br><span class="line">	private Component component;</span><br><span class="line"></span><br><span class="line">	public Decorator(Component component)&#123;</span><br><span class="line">		this.component = component;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void sampleOperation()&#123;</span><br><span class="line">		//委派给构件</span><br><span class="line">		component.sampleOperation();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体装饰角色</span><br><span class="line">public class ConcreteDecoratorA extends Decorator&#123;</span><br><span class="line">	public ConcreteDecoratorA(Component component)&#123;</span><br><span class="line">		super(component);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void sampleOperation()&#123;</span><br><span class="line">		super.sampleOperation();</span><br><span class="line">		//相关业务代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ConcreteDecoratorB extends Decorator&#123;</span><br><span class="line">	public ConcreteDecoratorB(Component component)&#123;</span><br><span class="line">		super(component);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void sampleOperation()&#123;</span><br><span class="line">		super.sampleOperation();</span><br><span class="line">		//相关业务代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>将抽象部分与它的实现部分分离，使他们都可以独立变化，目的是提高系统的可扩展性。<br><br><b>情景：</b>将n种颜色涂在n种形状里，如何设计？<br><br>|- 提供两个父类一个是颜色、一个形状，颜色父类和形状父类两个类都包含了相应的子类，然后根据需要对颜色和形状进行组合。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Shape &#123;</span><br><span class="line">	Color color;</span><br><span class="line">	public void setColor(Color color)&#123;</span><br><span class="line">		this.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line">public interface Color &#123;</span><br><span class="line">	void bepaint(String shape);</span><br><span class="line">&#125;</span><br><span class="line">public class black implements Color &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void bepaint(String shape) &#123;</span><br><span class="line">		System.out.println(&quot;黑色 --&gt;&quot; + shape);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class White implements Color &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void bepaint(String shape) &#123;</span><br><span class="line">		System.out.println(&quot;白色 --&gt;&quot; + shape);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Circle extends Shape&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void draw() &#123;</span><br><span class="line">	   color.bepaint(&quot;圆形&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Rectangle extends Shape&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void draw() &#123;</span><br><span class="line">	   color.bepaint(&quot;长方形&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Color white = new White();</span><br><span class="line">		Shape rectangle = new Rectangle();</span><br><span class="line">		rectangle.setColor(white);</span><br><span class="line">		rectangle.draw();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><br>白色 –&gt;长方形</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>以树的结构来描述部分与整体的概念，和文件系统类似，父文件夹、文件、子文件、子文件夹等等。</p>
<h3 id="安全式"><a href="#安全式" class="headerlink" title="安全式"></a>安全式</h3><p>要求管理聚集的地方只出现树枝构件中，而不出现在树叶构件中。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//抽象构件角色</span><br><span class="line">public interface Component&#123;</span><br><span class="line">	//输出组件自身的名称</span><br><span class="line">	public void printStruct(String preStr);</span><br><span class="line">&#125;</span><br><span class="line">//树枝构件</span><br><span class="line">public class Composite implements Component&#123;</span><br><span class="line">	//存储包含的子组件</span><br><span class="line">	private List&lt;Component&gt; childComponents	= new ArrayList&lt;&gt;();</span><br><span class="line">	//组合对象的名字</span><br><span class="line">	private String name;</span><br><span class="line">	public Composite(String name)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	//增加一个子构件</span><br><span class="line">	public void addChild(Component child)&#123;</span><br><span class="line">		childComponents.add(child);</span><br><span class="line">	&#125;</span><br><span class="line">	//删除一个子构件</span><br><span class="line">	public void removeChild(int index)&#123;</span><br><span class="line">		childComponents.remove(index);</span><br><span class="line">	&#125;</span><br><span class="line">	public List&lt;Component&gt; getChilds()&#123;</span><br><span class="line">		return childComponents;</span><br><span class="line">	&#125;</span><br><span class="line">	//打印</span><br><span class="line">	@Override</span><br><span class="line">	public void printStruct(String preStr)&#123;</span><br><span class="line">		System.out.println(preStr + &quot;+&quot; + this.name);</span><br><span class="line">		if(this.childComponents!=null)&#123;</span><br><span class="line">			preStr = &quot; &quot;;</span><br><span class="line">			for(Component c : childComponents)&#123;</span><br><span class="line">				c.printStruct(preStr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//树叶构件</span><br><span class="line">public class Leaf implements Component&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	public Leaf(String name)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void printStruct(String preStr)&#123;</span><br><span class="line">		System.out.println(preStr + &quot;-&quot; + name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Composite root = new Composite(&quot;服装&quot;);</span><br><span class="line">		Composite c1 = new Composite(&quot;男装&quot;);</span><br><span class="line">		Composite c2 = new Composite(&quot;女装&quot;);</span><br><span class="line">		</span><br><span class="line">		Leaf leaf1 = new Leaf(&quot;衬衫&quot;);</span><br><span class="line">		Leaf leaf2 = new Leaf(&quot;夹克&quot;);</span><br><span class="line">		Leaf leaf3 = new Leaf(&quot;裙子&quot;);</span><br><span class="line">		Leaf leaf4 = new Leaf(&quot;套装&quot;);</span><br><span class="line">		</span><br><span class="line">		root.addChild(c1);</span><br><span class="line">		root.addChild(c2);</span><br><span class="line">		c1.addChild(leaf1);</span><br><span class="line">		c1.addChild(leaf2);</span><br><span class="line">		c2.addChild(leaf3);</span><br><span class="line">		c2.addChild(leaf4);</span><br><span class="line">		</span><br><span class="line">		root.printStruct(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="透明式"><a href="#透明式" class="headerlink" title="透明式"></a>透明式</h3><p>透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 输出组建自身的名称</span><br><span class="line">	 */</span><br><span class="line">	public abstract void printStruct(String preStr);</span><br><span class="line">	/**</span><br><span class="line">	 * 聚集管理方法，增加一个子构件对象</span><br><span class="line">	 * @param child 子构件对象</span><br><span class="line">	 */</span><br><span class="line">	public void addChild(Component child)&#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 缺省实现，抛出异常，因为叶子对象没有此功能</span><br><span class="line">		 * 或者子组件没有实现这个功能</span><br><span class="line">		 */</span><br><span class="line">		throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 聚集管理方法，删除一个子构件对象</span><br><span class="line">	 * @param index 子构件对象的下标</span><br><span class="line">	 */</span><br><span class="line">	public void removeChild(int index)&#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 缺省实现，抛出异常，因为叶子对象没有此功能</span><br><span class="line">		 * 或者子组件没有实现这个功能</span><br><span class="line">		 */</span><br><span class="line">		throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 聚集管理方法，返回所有子构件对象</span><br><span class="line">	 */</span><br><span class="line">	public List&lt;Component&gt; getChild()&#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 缺省实现，抛出异常，因为叶子对象没有此功能</span><br><span class="line">		 * 或者子组件没有实现这个功能</span><br><span class="line">		 */</span><br><span class="line">		throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Composite和Leaf与上面一样，不一样的是Client端，Client不需要关心他们之间的关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Component root = new Composite(&quot;服装&quot;);</span><br><span class="line">		Component c1 = new Composite(&quot;男装&quot;);</span><br><span class="line">		Component c2 = new Composite(&quot;女装&quot;);</span><br><span class="line"></span><br><span class="line">		Component l1 = new Leaf(&quot;衬衫&quot;);</span><br><span class="line">		Component l2 = new Leaf(&quot;长袖&quot;);</span><br><span class="line">		Component l3 = new Leaf(&quot;毛衣&quot;);</span><br><span class="line">		Component l4 = new Leaf(&quot;貂皮&quot;);</span><br><span class="line">		root.addChild(c1);</span><br><span class="line">		root.addChild(c2);</span><br><span class="line">		root.addChild(l1);</span><br><span class="line">		root.addChild(l2);</span><br><span class="line">		root.addChild(l3);</span><br><span class="line">		root.addChild(l4);</span><br><span class="line">		root.printStruct(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式(Facade)"></a>外观模式(Facade)</h2><p>外观模式主要是将客户端直接与多个模块打交道的方式改为客户端与门面打交道，然后门面再去与各个模块打交道。客户可以不知道各个模块的具体实现甚至可以不用知道模块是否存在。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ModualA&#123;</span><br><span class="line">	public void test();</span><br><span class="line">&#125;</span><br><span class="line">public class ModualB&#123;</span><br><span class="line">	public void test();</span><br><span class="line">&#125;</span><br><span class="line">public class ModualC&#123;</span><br><span class="line">	public void test();</span><br><span class="line">&#125;</span><br><span class="line">public class Facade&#123;</span><br><span class="line">	public void test()&#123;</span><br><span class="line">		ModualA a = new ModualA();</span><br><span class="line">		a.test();</span><br><span class="line">		ModualB b = new ModualB();</span><br><span class="line">		b.test();</span><br><span class="line">		ModualC c = new ModualC();</span><br><span class="line">		c.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Facade facade = new Facade();</span><br><span class="line">		facade.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>|- Facade模式还可以用在子系统的某些功能不需要暴露给其他子系统的情况，如下：<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ModualA&#123;</span><br><span class="line">	//暴露给其他子系统的方法</span><br><span class="line">	public void test1()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	//不暴露给其他子系统的方法</span><br><span class="line">	private void test2()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ModualB&#123;</span><br><span class="line">	//暴露给其他子系统的方法</span><br><span class="line">	public void test1()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	//不暴露给其他子系统的方法</span><br><span class="line">	private void test2()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Facade&#123;</span><br><span class="line">	ModualA a = new ModualA();</span><br><span class="line">	ModualB b = new ModualB();</span><br><span class="line">	public void testa()&#123;</span><br><span class="line">		a.test1();</span><br><span class="line">	&#125;</span><br><span class="line">	public vid testb()&#123;</span><br><span class="line">		b.test2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>以共享的方式高效地支持大量的细粒度对象，目的是减少多次利用的对象重复创建对内存造成较大的开销。<br><br>|- 英文是flyweight，轻量级的。但是根据设计模式中的概念，将此译为享元，意思是共享元数据，相当于共享对象。<br><br>|- Java中String类型就是使用了享元模式，String对象是final类型的，Java中的字符串常量都是存在常量池中的。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abc&quot;;</span><br><span class="line">String b = &quot;abc&quot;;</span><br><span class="line">System.out.println(a==b);</span><br></pre></td></tr></table></figure></p>
<p>结果为：true</p>
<h3 id="单纯享元模式：共享对象"><a href="#单纯享元模式：共享对象" class="headerlink" title="单纯享元模式：共享对象"></a>单纯享元模式：共享对象</h3><p>共享对象<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyWeight&#123;</span><br><span class="line">	//具体业务类，这里简写一个</span><br><span class="line">	public void operation(Character state);</span><br><span class="line">&#125;</span><br><span class="line">public class ConcreteFlyWeight implements FlyWeight &#123;</span><br><span class="line">	private Character intrinsicState = null;</span><br><span class="line">	public ConcreteFlyWeight (Character state)&#123;</span><br><span class="line">		this.intrinsicState = state;</span><br><span class="line">	&#125;</span><br><span class="line">	public void operation(Character state)&#123;</span><br><span class="line">		System.out.println(&quot;intrinsicState :&quot; + this.intrinsicState);</span><br><span class="line">		System.out.println(&quot;extrinsicState :&quot; + state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FlyWeightFactory&#123;</span><br><span class="line">	private Map&lt;Character,FlyWeight&gt; files = new HashMap&lt;&gt;();</span><br><span class="line">	public FlyWeight factory(Character state)&#123;</span><br><span class="line">		FlyWeight fly = files.get(state);</span><br><span class="line">		//判断是否已经有了这个对象</span><br><span class="line">		if(fly ==null)&#123;</span><br><span class="line">			//如果没有，就创建，并且加入到集合中。</span><br><span class="line">			fly  = new ConcreteFlyWeight(state);</span><br><span class="line">			files.put(state,fly);</span><br><span class="line">		&#125;</span><br><span class="line">		//如果有，直接返回</span><br><span class="line">		return fly;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client&#123;</span><br><span class="line">	 public static void main(String[] args) &#123;</span><br><span class="line">		FlyWeightFactory factory = new FlyWeightFactory();</span><br><span class="line">		FlyWeight fly = factory.factory(new Character(&apos;a&apos;));</span><br><span class="line">		System.out.println(fly.hashCode());</span><br><span class="line">		fly.operation(&quot;first&quot;);</span><br><span class="line">		fly = factory.factory(new Character(&apos;b&apos;));</span><br><span class="line">		System.out.println(fly.hashCode());</span><br><span class="line">		fly.operation(&quot;second&quot;);</span><br><span class="line">		fly = factory.factory(new Character(&apos;a&apos;));</span><br><span class="line">		System.out.println(fly.hashCode());</span><br><span class="line">		fly.operation(&quot;third&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><br>21685669<br><br>instrinsicState :a<br><br>extrinsicState :first<br><br>19997786<br><br>instrinsicState :b<br><br>extrinsicState :second<br><br>21685669<br><br>instrinsicState :a<br><br>extrinsicState :third<br><br>由此可见，第一次和第三次对象的hashCode一样，说明在内存地址中是同一个对象。<br></p>
<h3 id="复杂享元模式"><a href="#复杂享元模式" class="headerlink" title="复杂享元模式"></a>复杂享元模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyWeight &#123;</span><br><span class="line">	void operation(String state);</span><br><span class="line">&#125;</span><br><span class="line">public class ConcreteFlyWeight implements FlyWeight &#123;</span><br><span class="line">	private Character intrinsicState = null;</span><br><span class="line">	public ConcreteFlyWeight(Character state) &#123;</span><br><span class="line">		this.intrinsicState = state;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void operation(String state) &#123;</span><br><span class="line">		System.out.println(&quot;instrinsicState :&quot;+ this.intrinsicState);</span><br><span class="line">		System.out.println(&quot;extrinsicState :&quot;+ state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CompositeConcreteFlyWeight implements FlyWeight &#123;</span><br><span class="line">	private Map&lt;Character,FlyWeight&gt; files =  new HashMap&lt;&gt;();</span><br><span class="line">	public void add(Character key,FlyWeight fly)&#123;</span><br><span class="line">		files.put(key, fly);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void operation(String state) &#123;</span><br><span class="line">		FlyWeight fly = null;</span><br><span class="line">		for(Object o : files.keySet())&#123;</span><br><span class="line">			fly = files.get(o);</span><br><span class="line">			System.out.println(o+&quot;: &quot;+fly.hashCode());</span><br><span class="line">			fly.operation(state);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FlyWeightFactory &#123;</span><br><span class="line">	private Map&lt;Character,FlyWeight&gt; files = new HashMap&lt;&gt;();</span><br><span class="line">	//复合享元工厂方法</span><br><span class="line">	public FlyWeight factory(List&lt;Character&gt; compositeStateList)&#123;</span><br><span class="line">		CompositeConcreteFlyWeight compoisteFlyWeight = new CompositeConcreteFlyWeight();</span><br><span class="line">		for(Character state : compositeStateList)&#123;</span><br><span class="line">			compoisteFlyWeight.add(state,this.factory(state));</span><br><span class="line">		&#125;</span><br><span class="line">		return compoisteFlyWeight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public FlyWeight factory(Character state) &#123;</span><br><span class="line">		FlyWeight fly = null;</span><br><span class="line">		fly = files.get(state);</span><br><span class="line">		if(fly == null)&#123;</span><br><span class="line">			fly = new ConcreteFlyWeight(state);</span><br><span class="line">			files.put(state,fly);</span><br><span class="line">		&#125;</span><br><span class="line">		return fly;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Character&gt; compositeState = new ArrayList&lt;&gt;();</span><br><span class="line">		compositeState.add(&apos;a&apos;);</span><br><span class="line">		compositeState.add(&apos;b&apos;);</span><br><span class="line">		compositeState.add(&apos;c&apos;);</span><br><span class="line">		compositeState.add(&apos;a&apos;);</span><br><span class="line">		compositeState.add(&apos;b&apos;);</span><br><span class="line">		FlyWeightFactory flyWeightFactory = new FlyWeightFactory();</span><br><span class="line">		FlyWeight compositeFly1 = flyWeightFactory.factory(compositeState);</span><br><span class="line">		FlyWeight compositeFly2 = flyWeightFactory.factory(compositeState);</span><br><span class="line">		compositeFly1.operation(&quot;composite --&gt;&quot;);</span><br><span class="line">		System.out.println(&quot;+++++++++++++++&quot;);</span><br><span class="line">		System.out.println(&quot;复合享元是不可以共享：&quot;+(compositeFly1 == compositeFly2));</span><br><span class="line">		System.out.println(compositeFly1.hashCode()+&quot;,&quot;+compositeFly2.hashCode());</span><br><span class="line">		Character state = &apos;a&apos;;</span><br><span class="line">		Character state2 = &apos;b&apos;;</span><br><span class="line">		FlyWeight fly1 = flyWeightFactory.factory(state);</span><br><span class="line">		FlyWeight fly2 = flyWeightFactory.factory(state);</span><br><span class="line">		FlyWeight fly3 = flyWeightFactory.factory(state2);</span><br><span class="line">		System.out.println(&quot;单纯享元是可以共享的：&quot;+(fly1 == fly2));</span><br><span class="line">		System.out.println(&quot;fly1: &quot; + fly1.hashCode()+&quot;,state: &quot;+state);</span><br><span class="line">		System.out.println(&quot;fly2: &quot; + fly2.hashCode()+&quot;,state: &quot;+state);</span><br><span class="line">		System.out.println(&quot;fly3: &quot; + fly3.hashCode()+&quot;,state: &quot;+state2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><br>a: 21685669<br><br>instrinsicState :a<br><br>extrinsicState :composite –&gt;<br><br>b: 19997786<br><br>instrinsicState :b<br><br>extrinsicState :composite –&gt;<br><br>c: 24079912<br><br>instrinsicState :c<br><br>extrinsicState :composite –&gt;<br><br>+++++++++++++++<br><br>复合享元是不可以共享：false<br><br>23050916,32379559<br><br>单纯享元是可以共享的：true<br><br>fly1: 21685669,state: a<br><br>fly2: 21685669,state: a<br><br>fly3: 19997786,state: b<br></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用，类似于中介，客户与客户之间无法直接进行交流，需要使用一个媒介。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractObject &#123;</span><br><span class="line">	public abstract void operation();</span><br><span class="line">&#125;</span><br><span class="line">public class RealObject extends AbstractObject &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void operation() &#123;</span><br><span class="line">		System.out.println(&quot;一些操作&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ProxyObject extends AbstractObject &#123;</span><br><span class="line">	RealObject realObject = new RealObject();</span><br><span class="line">	@Override</span><br><span class="line">	public void operation() &#123;</span><br><span class="line">		System.out.println(&quot;before do ----&quot;);</span><br><span class="line">		realObject.operation();</span><br><span class="line">		System.out.println(&quot;after do ----&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="三、-行为型"><a href="#三、-行为型" class="headerlink" title="三、 行为型"></a>三、 行为型</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>请求以链式传递，具体哪个类处理客户端不知。Tomcat的Filter处理过程便是责任链模式。<br><br>|- 抽象处理者：定义接口，并且持有下一个处理类的对象。<br><br>|- 具体处理者：可以根据条件判断是否处理或者移交给下一个处理类处理。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//抽象处理角色</span><br><span class="line">public abstract class Handler &#123;</span><br><span class="line">	//持有的后继责任对象</span><br><span class="line">	protected Handler successor;</span><br><span class="line">	//处理请求的方法</span><br><span class="line">	public abstract void handlerRequest();</span><br><span class="line">	public Handler getSuccessor() &#123;</span><br><span class="line">		return successor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setSuccessor(Handler successor) &#123;</span><br><span class="line">		this.successor = successor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体处理角色</span><br><span class="line">public class ConcreteHandler extends Handler &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void handlerRequest() &#123;</span><br><span class="line">		if (getSuccessor() != null) &#123;</span><br><span class="line">			System.out.println(&quot;放过请求&quot;);</span><br><span class="line">			getSuccessor().handlerRequest();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;处理请求&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//组装责任链</span><br><span class="line">		Handler handler1 = new ConcreteHandler();</span><br><span class="line">		Handler handler2 = new ConcreteHandler();</span><br><span class="line">		handler1.setSuccessor(handler2);</span><br><span class="line">		//提交请求</span><br><span class="line">		handler1.handlerRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>把发出命令的责任和执行命令的责任分离，委派给不同的对象。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//接收者</span><br><span class="line">public class Receiver &#123;</span><br><span class="line">	public void action()&#123;</span><br><span class="line">		//真正执行命令的操作</span><br><span class="line">		System.out.println(&quot;执行操作&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象命令接口</span><br><span class="line">public interface Command &#123;</span><br><span class="line">	//执行方法</span><br><span class="line">	void excute();</span><br><span class="line">&#125;</span><br><span class="line">//具体命令</span><br><span class="line">public class ConcreteCommand implements Command &#123;</span><br><span class="line">	//持有相应的接收者对象</span><br><span class="line">	private Receiver receiver = null;</span><br><span class="line"></span><br><span class="line">	public ConcreteCommand(Receiver receiver) &#123;</span><br><span class="line">		this.receiver = receiver;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void excute() &#123;</span><br><span class="line">		receiver.action();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//请求者</span><br><span class="line">public class Invoker &#123;</span><br><span class="line">	private Command command= null;</span><br><span class="line"></span><br><span class="line">	public Invoker(Command command) &#123;</span><br><span class="line">		this.command = command;</span><br><span class="line">	&#125;</span><br><span class="line">	public void action()&#123;</span><br><span class="line">		command.excute();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建接收者</span><br><span class="line">		Receiver receiver = new Receiver();</span><br><span class="line">		//创建命令对象，设置它的接收者</span><br><span class="line">		Command command = new ConcreteCommand(receiver);</span><br><span class="line">		//创建请求者，把命令设置进去</span><br><span class="line">		Invoker invoker = new Invoker(command);</span><br><span class="line">		//执行方法</span><br><span class="line">		invoker.action();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>注：</b>命令模式使得客户端和具体实现命令的接收者对象完全解耦。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br><br>|- 通俗来讲就是定义一些规则，用你自己的方式来实现这些规则，并且调用此规则来完成一些功能。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 表达式接口</span><br><span class="line"> */</span><br><span class="line">public interface Expression &#123;</span><br><span class="line">	boolean interpret(String context);</span><br><span class="line">&#125;</span><br><span class="line">public class TerminalExpression implements Expression &#123;</span><br><span class="line">	private String data;</span><br><span class="line"></span><br><span class="line">	public TerminalExpression(String data) &#123;</span><br><span class="line">		this.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean interpret(String context) &#123;</span><br><span class="line">		return context.contains(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 与表达式</span><br><span class="line"> */</span><br><span class="line">public class AndExpression implements Expression &#123;</span><br><span class="line">	private Expression expression1 = null;</span><br><span class="line">	private Expression expression2 = null;</span><br><span class="line"></span><br><span class="line">	public AndExpression(Expression expression1, Expression expression2) &#123;</span><br><span class="line">		this.expression1 = expression1;</span><br><span class="line">		this.expression2 = expression2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean interpret(String context) &#123;</span><br><span class="line">		return expression1.interpret(context)&amp;&amp; expression2.interpret(context);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 或表达式</span><br><span class="line"> */</span><br><span class="line">public class OrExpression implements Expression &#123;</span><br><span class="line">	private Expression expression1 = null;</span><br><span class="line">	private Expression expression2 = null;</span><br><span class="line"></span><br><span class="line">	public OrExpression(Expression expression1,Expression expression2) &#123;</span><br><span class="line">		this.expression1 = expression1;</span><br><span class="line">		this.expression2 = expression2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean interpret(String context) &#123;</span><br><span class="line">		boolean flag1 = expression1.interpret(context);</span><br><span class="line">		boolean flag2 = expression2.interpret(context);</span><br><span class="line">		return flag1|| flag2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	//规则：Robert 和 John 是男性</span><br><span class="line">	public static Expression getMaleExpression()&#123;</span><br><span class="line">		Expression robert = new TerminalExpression(&quot;Robert&quot;);</span><br><span class="line">		Expression john = new TerminalExpression(&quot;john&quot;);</span><br><span class="line">		return new OrExpression(robert,john);</span><br><span class="line">	&#125;</span><br><span class="line">	//规则：Julie 是一个已婚的女性</span><br><span class="line">	public static Expression getMarriedWomanExpression()&#123;</span><br><span class="line">		Expression julie = new TerminalExpression(&quot;Julie&quot;);</span><br><span class="line">		Expression married = new TerminalExpression(&quot;Married&quot;);</span><br><span class="line">		return new AndExpression(julie, married);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Expression isMale = getMaleExpression();</span><br><span class="line">		Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;john&quot;));</span><br><span class="line">		System.out.println(&quot;Julie is a married women? &quot;</span><br><span class="line">				+ isMarriedWoman.interpret(&quot;Married Julie&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码运行结果为：<br><br>John is male? true<br><br>Julie is a married women? true<br></p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>为了减少同事类之间的耦合，独立改变他们之间的交互。<br><br>|- 同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。<br><br>|- <b>情景：</b>类A和类B都持有一个数，要保证A中的数字改变的时候B中的数字乘以100，B中的数字改变的时候，A中的数字除以100。<br><br>例（<b>传统方式</b>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract AbstractColleague&#123;</span><br><span class="line">	protected int number;</span><br><span class="line">	public void setNumber(int number)&#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNumber()&#123;</span><br><span class="line">		return number;</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract void setNumber(int number,AbstractColleague colleague);</span><br><span class="line">&#125;</span><br><span class="line">public class ColleagueA extends AbstractColleague&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void setNumber(int number,AbstractColleague colleague)&#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">		colleague.setNumber(number * 100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ColleagueB extends AbstractColleague&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void setNumber(int number,AbstractColleague colleague)&#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">		colleague.setNumber(number / 100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client()&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		AbstractColleague colleagueA = new ColleagueA();</span><br><span class="line">		AbstractColleague colleagueB = new ColleagueB();</span><br><span class="line">		colleagueA.setNumber(500,colleagueB);</span><br><span class="line">		System.out.println(&quot;---------设置A影响B---------&quot;);</span><br><span class="line">		System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber());</span><br><span class="line">		System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber());</span><br><span class="line">		colleagueB.setNumber(2500600,colleagueA);</span><br><span class="line">		System.out.println(&quot;---------设置B影响A---------&quot;);</span><br><span class="line">		System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber());</span><br><span class="line">		System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber());		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><br>———设置A影响B———<br><br>collA的值 :500<br><br>collB的值 :50000<br><br>———设置B影响A———<br><br>collA的值 :25006<br><br>collB的值 :2500600<br><br><br><br>例（<b>中介者模式</b>：让中介类参与其中，避免A和B的直接交互）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 中介者模式</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractColleague &#123;</span><br><span class="line">	protected int number;</span><br><span class="line"></span><br><span class="line">	public int getNumber() &#123;</span><br><span class="line">		return number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setNumber(int number) &#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	//这里传入的是一个中介类</span><br><span class="line">	public abstract void setNumber(int number,AbstractMediator media);</span><br><span class="line">	public void test()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ColleagueA extends AbstractColleague &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void setNumber(int number, AbstractMediator mediator) &#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">		//让中介类来完成功能</span><br><span class="line">		mediator.affectB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ColleagueB extends AbstractColleague &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void setNumber(int number, AbstractMediator mediator) &#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">		mediator.affectA();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractMediator &#123;</span><br><span class="line">	//持有两个实际对象的目的是让他们的状态随着改变。</span><br><span class="line">	protected AbstractColleague A;</span><br><span class="line">	protected AbstractColleague B;</span><br><span class="line">	//构造方法通常是一种非常好的做法，可以让类的状态一直保持着传递状态。</span><br><span class="line">	public AbstractMediator(AbstractColleague a, AbstractColleague b) &#123;</span><br><span class="line">		A = a;</span><br><span class="line">		B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract void affectB();</span><br><span class="line"></span><br><span class="line">	public abstract void affectA();</span><br><span class="line">&#125;</span><br><span class="line">public class Mediator extends AbstractMediator &#123;</span><br><span class="line">	public Mediator(AbstractColleague colleagueA,AbstractColleague colleagueB) &#123;</span><br><span class="line">		super(colleagueA,colleagueB);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void affectB() &#123;</span><br><span class="line">		int number = A.getNumber();</span><br><span class="line">		B.setNumber(number * 100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void affectA() &#123;</span><br><span class="line">		int number = B.getNumber();</span><br><span class="line">		A.setNumber(number / 100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		AbstractColleague colleagueA = new ColleagueA();</span><br><span class="line">		AbstractColleague colleagueB = new ColleagueB();</span><br><span class="line">		AbstractMediator mediator = new Mediator(colleagueA,colleagueB);</span><br><span class="line">		colleagueA.setNumber(500,mediator);</span><br><span class="line">		System.out.println(&quot;---------设置A影响B---------&quot;);</span><br><span class="line">		System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber());</span><br><span class="line">		System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber());</span><br><span class="line">		colleagueB.setNumber(2500600,mediator);</span><br><span class="line">		System.out.println(&quot;---------设置B影响A---------&quot;);</span><br><span class="line">		System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber());</span><br><span class="line">		System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>———设置A影响B———<br><br>collA的值 :500<br><br>collB的值 :50000<br><br>———设置B影响A———<br><br>collA的值 :25006<br><br>collB的值 :2500600<br><br><br><br><b>注：</b>一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。<br><br>&nbsp;&nbsp;|- 网状结构：类与类之间是多对多的关系，牵一发而动全身。<br><br>&nbsp;&nbsp;|- 星状结构：各类都与中介类单独联系，不与其他的类牵连。<br></p>
<h2 id="迭代模式（Cursor）"><a href="#迭代模式（Cursor）" class="headerlink" title="迭代模式（Cursor）"></a>迭代模式（Cursor）</h2><p>可以顺序地访问一个聚集中的元素而不暴露聚集的内部表象（internal representation）。<br><br>|- Java中的集合框架很多都使用的迭代模式的聚集，如Vector、ArrayList、HashSet、HashMap、Hashtable等。<br><br><b>例：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象聚集角色类</span><br><span class="line"> */</span><br><span class="line">public abstract class Aggregate &#123;</span><br><span class="line">	public abstract Iterator createInterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>具体聚集角色类:</li>
<li>实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteAggregate extends Aggregate &#123;</span><br><span class="line">	private Object[] objArray = null;</span><br><span class="line"></span><br><span class="line">	public ConcreteAggregate(Object[] objArray) &#123;</span><br><span class="line">		this.objArray = objArray;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Iterator createInterator() &#123;</span><br><span class="line">		return new ConcreteIterator(this);</span><br><span class="line">	&#125;</span><br><span class="line">	public Object getElement(int index)&#123;</span><br><span class="line">		if(index &lt;objArray.length)&#123;</span><br><span class="line">			return objArray[index];</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return objArray.length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>　抽象迭代子角色类<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">	//move to first</span><br><span class="line">	void first();</span><br><span class="line">	//move to last</span><br><span class="line">	void next();</span><br><span class="line"></span><br><span class="line">	boolean isLast();</span><br><span class="line"></span><br><span class="line">	Object currentItem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>具体迭代子角色<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteIterator implements Iterator &#123;</span><br><span class="line">	private ConcreteAggregate agg;</span><br><span class="line">	private int index = 0;</span><br><span class="line">	private int size = 0;</span><br><span class="line"></span><br><span class="line">	public ConcreteIterator(ConcreteAggregate agg) &#123;</span><br><span class="line">		this.agg = agg;</span><br><span class="line">		this.index = 0;</span><br><span class="line">		this.size = agg.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void first() &#123;</span><br><span class="line">		index = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void next() &#123;</span><br><span class="line">		if(index &lt; size)&#123;</span><br><span class="line">			index ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isLast() &#123;</span><br><span class="line">		return (index &gt;= size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object currentItem() &#123;</span><br><span class="line">		return agg.getElement(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	public void operation()&#123;</span><br><span class="line">		Object[] objArray = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;&#125;;</span><br><span class="line">		Aggregate agg = new ConcreteAggregate(objArray);</span><br><span class="line">		Iterator iter = agg.createInterator();</span><br><span class="line">		while (!iter.isLast())&#123;</span><br><span class="line">			System.out.println(iter.currentItem());</span><br><span class="line">			iter.next();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Client client = new Client();</span><br><span class="line">		client.operation();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<br><br>例：<br>/**</p>
<ul>
<li>抽象主题角色类：把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。</li>
<li>抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Subject &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 用来保存注册的观察者对象</span><br><span class="line">	 */</span><br><span class="line">	private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;();</span><br><span class="line">	/**</span><br><span class="line">	 * 注册观察者对象</span><br><span class="line">	 * @param observer    观察者对象</span><br><span class="line">	 */</span><br><span class="line">	public void attach(Observer observer)&#123;</span><br><span class="line"></span><br><span class="line">		list.add(observer);</span><br><span class="line">		System.out.println(&quot;Attached an observer&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 删除观察者对象</span><br><span class="line">	 * @param observer    观察者对象</span><br><span class="line">	 */</span><br><span class="line">	public void detach(Observer observer)&#123;</span><br><span class="line"></span><br><span class="line">		list.remove(observer);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 通知所有注册的观察者对象</span><br><span class="line">	 */</span><br><span class="line">	public void nodifyObservers(String newState)&#123;</span><br><span class="line"></span><br><span class="line">		for(Observer observer : list)&#123;</span><br><span class="line">			observer.update(newState);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>具体角色类：将有关状态存入具体观察者对象；</li>
<li>在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteSubject extends Subject &#123;</span><br><span class="line">	private String state;</span><br><span class="line"></span><br><span class="line">	public String getState() &#123;</span><br><span class="line">		return state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void change(String newState)&#123;</span><br><span class="line">		state = newState;</span><br><span class="line">		System.out.println(&quot;主题状态为：&quot; + state);</span><br><span class="line">		//状态发生改变，通知各个观察者</span><br><span class="line">		this.nodifyObservers(state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>抽象观察者角色类：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">	//更新方法</span><br><span class="line">	void update(String state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>具体观察者角色类：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态协调。</li>
<li>如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteObserver implements Observer&#123;</span><br><span class="line">	//观察者的状态</span><br><span class="line">	private String observerState;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void update(String state) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 更新观察者的状态，使其与目标的状态保持一致</span><br><span class="line">		 */</span><br><span class="line">		observerState = state;</span><br><span class="line">		System.out.println(&quot;状态为：&quot;+observerState);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建主题对象</span><br><span class="line">		ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line">		//创建观察者对象</span><br><span class="line">		Observer observer = new ConcreteObserver();</span><br><span class="line">		//将观察者对象登记到主题对象上</span><br><span class="line">		subject.attach(observer);</span><br><span class="line">		//改变主题对象的状态</span><br><span class="line">		subject.change(&quot;new state&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>Attached an observer<br><br>主题状态为：new state<br><br>状态为：new state<br></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。<br><br>|- 对算法的包装。<br><br>|- 简而言之：准备一组算法，并将每一个算法封装起来，使得它们可以互换。<br><br>例（思路模板）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象策略类</span><br><span class="line"> */</span><br><span class="line">public interface Strategy &#123;</span><br><span class="line">	//策略方法</span><br><span class="line">	void strategyInterface();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 环境角色类</span><br><span class="line"> */</span><br><span class="line">public class Context &#123;</span><br><span class="line">	//持有一个具体策略的对象</span><br><span class="line">	private Strategy strategy;</span><br><span class="line">	/**</span><br><span class="line">	 * 构造函数，传入一个具体策略对象</span><br><span class="line">	 * @param strategy    具体策略对象</span><br><span class="line">	 */</span><br><span class="line">	public Context(Strategy strategy)&#123;</span><br><span class="line">		this.strategy = strategy;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 策略方法</span><br><span class="line">	 */</span><br><span class="line">	public void contextInterface()&#123;</span><br><span class="line">		strategy.strategyInterface();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 具体策略类</span><br><span class="line"> */</span><br><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void strategyInterface() &#123;</span><br><span class="line">		//业务代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 具体策略类</span><br><span class="line"> */</span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void strategyInterface() &#123;</span><br><span class="line">		//业务代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例（具体事例：图书打折问题，初级会员没有折扣，中级会员9折，高级会员8折）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象折扣类</span><br><span class="line"> */</span><br><span class="line">public interface MemberStrategy &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 计算图书的价格</span><br><span class="line">	 * @param booksPrice  图书的原价</span><br><span class="line">	 * @return    计算出打折后的价格</span><br><span class="line">	 */</span><br><span class="line">	 double calcPrice(double booksPrice);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 初级会员</span><br><span class="line"> */</span><br><span class="line">public class PrimaryMemberStrategy implements MemberStrategy &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public double calcPrice(double booksPrice) &#123;</span><br><span class="line">		System.out.println(&quot;对于初级会员的没有折扣&quot;);</span><br><span class="line">		return booksPrice;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 中级会员9折</span><br><span class="line"> */</span><br><span class="line">public class IntermediateMemberStrategy implements MemberStrategy &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public double calcPrice(double booksPrice) &#123;</span><br><span class="line">		System.out.println(&quot;中级会员9折&quot;);</span><br><span class="line">		return booksPrice * 0.9;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 高级会员8折</span><br><span class="line"> */</span><br><span class="line">public class AdvancedMemberStrategy implements MemberStrategy &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public double calcPrice(double booksPrice) &#123;</span><br><span class="line">		System.out.println(&quot;高级会员8折&quot;);</span><br><span class="line">		return booksPrice * 0.8;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Price &#123;</span><br><span class="line">	private MemberStrategy strategy;</span><br><span class="line"></span><br><span class="line">	public Price(MemberStrategy strategy) &#123;</span><br><span class="line">		this.strategy = strategy;</span><br><span class="line">	&#125;</span><br><span class="line">	//计算书价</span><br><span class="line">	public double quote(double booksPrice)&#123;</span><br><span class="line">		return this.strategy.calcPrice(booksPrice);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MemberStrategy memberStrategy = new AdvancedMemberStrategy();</span><br><span class="line">		Price price = new Price(memberStrategy);</span><br><span class="line">		double quote = price.quote(300);</span><br><span class="line">		System.out.println(&quot;图书最终价格为：&quot;+quote);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>高级会员8折<br><br>图书最终价格为：240.0<br></p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。<br><br>|- 不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。<br><br>|- 模板方法在Servlet中的应用：使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;|- ttpService类提供了一个service()方法，<br><br>&nbsp;&nbsp;&nbsp;&nbsp;|- 这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;|- 这些do方法需要由HttpServlet的具体子类提供。<br><br>因此这是典型的模板方法模式。</p>
<p>|- 关键：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractTemplate &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 模板方法</span><br><span class="line">	 */</span><br><span class="line">	public void templateMethod()&#123;</span><br><span class="line">		abstractMethod();</span><br><span class="line">		hookMethod();</span><br><span class="line">		concreteMethod();</span><br><span class="line">	&#125;</span><br><span class="line">	//基本方法（由子类实现）</span><br><span class="line">	protected abstract void abstractMethod();</span><br><span class="line">	//基本方法（空方法）</span><br><span class="line">	protected void hookMethod()&#123;&#125;</span><br><span class="line">	//基本方法（已经实现）</span><br><span class="line">	protected final void concreteMethod()&#123;</span><br><span class="line">		//业务相关代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ConcreteTemplate extends AbstractTemplate &#123;</span><br><span class="line">	//基本方法实现</span><br><span class="line">	@Override</span><br><span class="line">	protected void abstractMethod() &#123;</span><br><span class="line">		//业务相关代码</span><br><span class="line">	&#125;</span><br><span class="line">	//重写父类方法</span><br><span class="line">	@Override</span><br><span class="line">	protected void hookMethod() &#123;</span><br><span class="line">		//业务相关代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>封装一些施加于某种数据结构元素之上的操作。<br><br>|- 分派的概念：根据对象的类型而对方法进行的选择。<br></p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。<br><br>例（墨子骑马的故事作为例子，墨子可以骑白马或者黑马）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Mozi &#123;</span><br><span class="line">	public void ride(Horse h)&#123;</span><br><span class="line">		System.out.println(&quot;骑马&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void ride(WhiteHorse wh)&#123;</span><br><span class="line">		System.out.println(&quot;骑白马&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void ride(BlackHorse bh)&#123;</span><br><span class="line">		System.out.println(&quot;骑黑马&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Horse wh = new WhiteHorse();</span><br><span class="line">		Horse bh = new BlackHorse();</span><br><span class="line">		Mozi mozi = new Mozi();</span><br><span class="line">		mozi.ride(wh);</span><br><span class="line">		mozi.ride(bh);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>骑马<br><br>骑马<br><br><b>注：</b>但是两次对ride()方法的调用传入的是不同的参数，也就是wh和bh。它们虽然具有不同的真实类型，但是它们的静态类型都是一样的，均是Horse类型。<br><br>|- <b>由此可见</b>：重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>发生在运行时期，动态分派动态地置换掉某个方法。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Horse &#123;</span><br><span class="line">	public void eat()&#123;</span><br><span class="line">		System.out.println(&quot;马吃草&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BlackHorse extends Horse &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;黑马吃草&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Horse horse = new BlackHorse();</span><br><span class="line">		horse.eat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>黑马吃草<br><br><b>因此，对比可知：</b>问题的核心就是Java编译器在编译时期并不总是知道哪些代码会被执行。<br><br>|- 编译器仅仅知道对象的静态类型，而不知道对象的真实类型。<br><br>|- 方法的调用则是根据对象的真实类型，而不是静态类型。<br><br>这样一来，上面最后一行的eat()方法调用的是BlackHorse类的eat()方法，打印的是“黑马吃草”。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。<br><br>|- <b>简而言之</b>，复制一份对象的内部状态，保存下来以备不时之需。<br></p>
<h3 id="白箱备忘录模式"><a href="#白箱备忘录模式" class="headerlink" title="白箱备忘录模式"></a>白箱备忘录模式</h3><p>备忘录角色对任何对象都提供一个接口（宽接口），备忘录角色的内部所存储的状态就对所有对象公开。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 发起人角色类</span><br><span class="line"> */</span><br><span class="line">public class Originator &#123;</span><br><span class="line">	//持有一个状态标志</span><br><span class="line">	private String state;</span><br><span class="line"></span><br><span class="line">	public Memento createMemento()&#123;</span><br><span class="line">		return new Memento(state);</span><br><span class="line">	&#125;</span><br><span class="line">	public void restoreMemento(Memento memento)&#123;</span><br><span class="line">		this.state = memento.getState();</span><br><span class="line">	&#125;</span><br><span class="line">	public String getState() &#123;</span><br><span class="line">		return state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setState(String state) &#123;</span><br><span class="line">		this.state = state;</span><br><span class="line">		System.out.println(&quot;当前状态：&quot; + state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 备忘录角色类</span><br><span class="line"> */</span><br><span class="line">public class Memento &#123;</span><br><span class="line">	private String state;</span><br><span class="line"></span><br><span class="line">	public Memento(String state) &#123;</span><br><span class="line">		this.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setState(String state) &#123;</span><br><span class="line">		this.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getState() &#123;</span><br><span class="line">		return state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 负责人角色</span><br><span class="line"> */</span><br><span class="line">public class CareTaker &#123;</span><br><span class="line">	private Memento memento;</span><br><span class="line">	//获取备忘录</span><br><span class="line">	public Memento retrieveMemento()&#123;</span><br><span class="line">		return this.memento;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置备忘录</span><br><span class="line">	public void saveMemento(Memento memento)&#123;</span><br><span class="line">		this.memento = memento;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Originator o = new Originator();</span><br><span class="line">		CareTaker care = new CareTaker();</span><br><span class="line">		//创建</span><br><span class="line">		o.setState(&quot;on&quot;);</span><br><span class="line">		care.saveMemento(o.createMemento());</span><br><span class="line">		//修改</span><br><span class="line">		o.setState(&quot;off&quot;);</span><br><span class="line">		//恢复</span><br><span class="line">		o.restoreMemento(care.retrieveMemento());</span><br><span class="line">		System.out.println(o.getState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>当前状态：on<br><br>当前状态：off<br><br>on</p>
<h3 id="黑箱备忘录模式"><a href="#黑箱备忘录模式" class="headerlink" title="黑箱备忘录模式"></a>黑箱备忘录模式</h3><p>备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。<br><br>|- 在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 发起人角色类</span><br><span class="line"> */</span><br><span class="line">public class Originator &#123;</span><br><span class="line">   private String state;</span><br><span class="line"></span><br><span class="line">	public String getState() &#123;</span><br><span class="line">		return state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setState(String state) &#123;</span><br><span class="line">		this.state = state;</span><br><span class="line">		System.out.println(&quot;当前状态 --&gt;&quot; + state);</span><br><span class="line">	&#125;</span><br><span class="line">	public MementoIF createMemento()&#123;</span><br><span class="line">		return new Memento(state);</span><br><span class="line">	&#125;</span><br><span class="line">	public void restoreMemento(MementoIF memento)&#123;</span><br><span class="line">		this.setState(((Memento)memento).getState());</span><br><span class="line">	</span><br><span class="line">	//以内部类的方式，将备忘录角色只为发起人角色提供功能。</span><br><span class="line">	private class Memento implements MementoIF&#123;</span><br><span class="line">		private String state;</span><br><span class="line"></span><br><span class="line">		public Memento(String state) &#123;</span><br><span class="line">			this.state = state;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public String getState() &#123;</span><br><span class="line">			return state;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void setState(String state) &#123;</span><br><span class="line">			this.state = state;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 标识接口，窄接口</span><br><span class="line"> */</span><br><span class="line">public interface MementoIF &#123;</span><br><span class="line">&#125;</span><br><span class="line">//负责人角色类</span><br><span class="line">public class CareTaker &#123;</span><br><span class="line">	private MementoIF memento;</span><br><span class="line">	public MementoIF retrieveMemento()&#123;</span><br><span class="line">		return memento;</span><br><span class="line">	&#125;</span><br><span class="line">	public void saveMemento(MementoIF memento)&#123;</span><br><span class="line">		this.memento = memento;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Originator o = new Originator();</span><br><span class="line">		CareTaker careTak</span><br><span class="line">		er = new CareTaker();</span><br><span class="line">		o.setState(&quot;on&quot;);</span><br><span class="line">		 //此时虽然无法直接访问内部类Menmento，但是通过createMemento()方法可以得到。</span><br><span class="line">		careTaker.saveMemento(o.createMemento());</span><br><span class="line">		o.setState(&quot;off&quot;);</span><br><span class="line">		o.restoreMemento(careTaker.retrieveMemento());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>当前状态 –&gt;on<br><br>当前状态 –&gt;off<br><br>当前状态 –&gt;on<br></p>
<h3 id="多重检查点"><a href="#多重检查点" class="headerlink" title="多重检查点"></a>多重检查点</h3><p>往往系统中部只需要恢复对象的某一个状态，而是要恢复多个状态。<br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line">	private List&lt;String&gt; states;</span><br><span class="line">	//检查点指数</span><br><span class="line">	private int index;</span><br><span class="line">	/**</span><br><span class="line">	 * 构造函数</span><br><span class="line">	 */</span><br><span class="line">	public Originator()&#123;</span><br><span class="line">		states = new ArrayList&lt;String&gt;();</span><br><span class="line">		index = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 工厂方法，返还一个新的备忘录对象</span><br><span class="line">	 */</span><br><span class="line">	public Memento createMemento()&#123;</span><br><span class="line">		return new Memento(states , index);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 将发起人恢复到备忘录对象记录的状态上</span><br><span class="line">	 */</span><br><span class="line">	public void restoreMemento(Memento memento)&#123;</span><br><span class="line">		states = memento.getStates();</span><br><span class="line">		index = memento.getIndex();</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 状态的赋值方法</span><br><span class="line">	 */</span><br><span class="line">	public void setState(String state)&#123;</span><br><span class="line">		states.add(state);</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 辅助方法，打印所有状态</span><br><span class="line">	 */</span><br><span class="line">	public void printStates()&#123;</span><br><span class="line"></span><br><span class="line">		for(String state : states)&#123;</span><br><span class="line">			System.out.println(state);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Memento &#123;</span><br><span class="line">	private List&lt;String&gt; states;</span><br><span class="line">	private int index;</span><br><span class="line">	/**</span><br><span class="line">	 * 构造函数</span><br><span class="line">	 */</span><br><span class="line">	public Memento(List&lt;String&gt; states , int index)&#123;</span><br><span class="line">		this.states = new ArrayList&lt;String&gt;(states);</span><br><span class="line">		this.index = index;</span><br><span class="line">	&#125;</span><br><span class="line">	public List&lt;String&gt; getStates() &#123;</span><br><span class="line">		return states;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getIndex() &#123;</span><br><span class="line">		return index;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CareTaker &#123;</span><br><span class="line">	private Originator o;</span><br><span class="line">	private List&lt;Memento&gt; mementos = new ArrayList&lt;Memento&gt;();</span><br><span class="line">	private int current;</span><br><span class="line">	/**</span><br><span class="line">	 * 构造函数</span><br><span class="line">	 */</span><br><span class="line">	public CareTaker(Originator o)&#123;</span><br><span class="line">		this.o = o;</span><br><span class="line">		current = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 创建一个新的检查点</span><br><span class="line">	 */</span><br><span class="line">	public int createMemento()&#123;</span><br><span class="line">		Memento memento = o.createMemento();</span><br><span class="line">		mementos.add(memento);</span><br><span class="line">		return current++;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 将发起人恢复到某个检查点</span><br><span class="line">	 */</span><br><span class="line">	public void restoreMemento(int index)&#123;</span><br><span class="line">		Memento memento = mementos.get(index);</span><br><span class="line">		o.restoreMemento(memento);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 将某个检查点删除</span><br><span class="line">	 */</span><br><span class="line">	public void removeMemento(int index)&#123;</span><br><span class="line">		mementos.remove(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Originator o = new Originator();</span><br><span class="line">		CareTaker c = new CareTaker(o);</span><br><span class="line">		//改变状态</span><br><span class="line">		o.setState(&quot;state 0&quot;);</span><br><span class="line">		//建立一个检查点</span><br><span class="line">		c.createMemento();</span><br><span class="line">		//改变状态</span><br><span class="line">		o.setState(&quot;state 1&quot;);</span><br><span class="line">		//建立一个检查点</span><br><span class="line">		c.createMemento();</span><br><span class="line">		//改变状态</span><br><span class="line">		o.setState(&quot;state 2&quot;);</span><br><span class="line">		//建立一个检查点</span><br><span class="line">		c.createMemento();</span><br><span class="line">		//改变状态</span><br><span class="line">		o.setState(&quot;state 3&quot;);</span><br><span class="line">		//建立一个检查点</span><br><span class="line">		c.createMemento();</span><br><span class="line">		//打印出所有检查点</span><br><span class="line">		o.printStates();</span><br><span class="line">		System.out.println(&quot;-----------------恢复检查点-----------------&quot;);</span><br><span class="line">		//恢复到第二个检查点</span><br><span class="line">		c.restoreMemento(2);</span><br><span class="line">		//打印出所有检查点</span><br><span class="line">		o.printStates();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>state 0<br><br><br>state 1<br><br>state 2<br><br>state 3<br><br>—————–恢复检查点—————–<br><br>state 0<br><br>state 1<br><br>state 2<br></p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>允许一个对象在其内部状态改变的时候改变其行为，这个对象看上去就像是改变了它的类一样。<br><br>|- 把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。<br><br>例（思路模型）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//上下文对象</span><br><span class="line">public class Context &#123;</span><br><span class="line">	private State state;</span><br><span class="line"></span><br><span class="line">	public void setState(State state) &#123;</span><br><span class="line">		this.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	//用户感兴趣的接口方法</span><br><span class="line">	public void request(String sampleParam)&#123;</span><br><span class="line">		state.handle(sampleParam);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 抽象状态类</span><br><span class="line"> */</span><br><span class="line">public interface State &#123;</span><br><span class="line">	//状态对应的处理</span><br><span class="line">	void handle(String sampleParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStateA implements State &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void handle(String sampleParam) &#123;</span><br><span class="line">		System.out.println(&quot;ConcreteStateA handle :&quot;+sampleParam);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ConcreteStateB implements State &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void handle(String sampleParam) &#123;</span><br><span class="line">		System.out.println(&quot;ConcreteStateB handle :&quot;+sampleParam);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建状态</span><br><span class="line">		State stateA = new ConcreteStateA();</span><br><span class="line">		State stateB = new ConcreteStateB();</span><br><span class="line">		//创建环境</span><br><span class="line">		Context context = new Context();</span><br><span class="line">		//将状态设置到环境中</span><br><span class="line">		context.setState(stateA);</span><br><span class="line">		//请求</span><br><span class="line">		context.request(&quot;test&quot;);</span><br><span class="line">		context.setState(stateB);</span><br><span class="line">		//请求</span><br><span class="line">		context.request(&quot;test&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>ConcreteStateA handle :test<br><br>ConcreteStateB handle :test<br><br><br><br>例（具体事例：投票事件，分为普通投票、重复投票、恶意刷票、黑名单禁止刷票几种状态）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public interface VoteState &#123;</span><br><span class="line">	/**</span><br><span class="line">	 *</span><br><span class="line">	 * @param user 投票人</span><br><span class="line">	 * @param voteItem 投票项目</span><br><span class="line">	 * @param voteManager 投票上下文，用来传递上下文状态。</span><br><span class="line">	 */</span><br><span class="line">	 void vote(String user,String voteItem,VoteManager voteManager);</span><br><span class="line">&#125;</span><br><span class="line">public class NormalVote implements VoteState &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void vote(String user, String voteItem, VoteManager voteManager) &#123;</span><br><span class="line">		//正常投票，记录到投票记录中</span><br><span class="line">		voteManager.getMapVote().put(user, voteItem);</span><br><span class="line">		System.out.println(&quot;恭喜投票成功&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RepeatVoteState implements VoteState &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void vote(String user, String voteItem, VoteManager voteManager) &#123;</span><br><span class="line">		//重复投票，暂时不做处理</span><br><span class="line">		System.out.println(&quot;请不要重复投票&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SpiteVoteState implements VoteState &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void vote(String user, String voteItem, VoteManager voteManager) &#123;</span><br><span class="line">		// 恶意投票，取消用户的投票资格，并取消投票记录</span><br><span class="line">		String str = voteManager.getMapVote().get(user);</span><br><span class="line">		if(str != null)&#123;</span><br><span class="line">			voteManager.getMapVote().remove(user);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;你有恶意刷屏行为，取消投票资格&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BlackVoteState implements VoteState &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void vote(String user, String voteItem, VoteManager voteManager) &#123;</span><br><span class="line">		//记录黑名单中，禁止登录系统</span><br><span class="line">		System.out.println(&quot;进入黑名单，将禁止登录和使用本系统&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class VoteManager &#123;</span><br><span class="line">	//持有状态处理对象</span><br><span class="line">	private VoteState state = null;</span><br><span class="line">	//记录用户投票的结果</span><br><span class="line">	private Map&lt;String,String&gt; mapVote = new HashMap&lt;&gt;();</span><br><span class="line">	//记录用户投票次数</span><br><span class="line">	private Map&lt;String,Integer&gt; mapVoteCount = new HashMap&lt;&gt;();</span><br><span class="line">	//获取用户投票结果</span><br><span class="line">	public Map&lt;String,String&gt; getMapVote()&#123;</span><br><span class="line">		return mapVote;</span><br><span class="line">	&#125;</span><br><span class="line">	public void vote(String user,String voteItem)&#123;</span><br><span class="line">		Integer oldVoteCount = mapVoteCount.get(user);</span><br><span class="line">		if(oldVoteCount == null)&#123;</span><br><span class="line">			oldVoteCount = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		oldVoteCount += 1;</span><br><span class="line">		mapVoteCount.put(user,oldVoteCount);</span><br><span class="line">		if(oldVoteCount == 1)&#123;</span><br><span class="line">			state = new NormalVote();</span><br><span class="line">		&#125; else if (oldVoteCount &gt; 1 &amp;&amp; oldVoteCount &lt; 5) &#123;</span><br><span class="line">			state = new RepeatVoteState();</span><br><span class="line">		&#125; else if (oldVoteCount &gt;= 5 &amp;&amp; oldVoteCount &lt; 8) &#123;</span><br><span class="line">			state = new SpiteVoteState();</span><br><span class="line">		&#125; else if (oldVoteCount &gt; 8) &#123;</span><br><span class="line">			state = new BlackVoteState();</span><br><span class="line">		&#125;</span><br><span class="line">		state.vote(user,voteItem,this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		VoteManager voteManager = new VoteManager();</span><br><span class="line">		for(int i = 0;i&lt;9;i++)&#123;</span><br><span class="line">			voteManager.vote(&quot;u1&quot;,&quot;abc&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><br>恭喜投票成功<br><br>请不要重复投票<br><br>请不要重复投票<br><br>请不要重复投票<br><br>你有恶意刷屏行为，取消投票资格<br><br>你有恶意刷屏行为，取消投票资格<br><br>你有恶意刷屏行为，取消投票资格<br><br>你有恶意刷屏行为，取消投票资格<br><br>进入黑名单，将禁止登录和使用本系统<br></p>
<p><br><br></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://blog.mmzsblog.cn/Design-Patterns/designPatterns/" title="精炼23种设计模式" target="_blank" rel="external">https://blog.mmzsblog.cn/Design-Patterns/designPatterns/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/mmzsblog" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/mmzsblog" target="_blank"><span class="text-dark">mmzsblog</span><small class="ml-1x">Web Developer &amp; Java Developer</small></a></h3>
        <div>这里是一群热爱技术的人儿！这里只聊技术，不聊其它，因为没有比编程更纯粹的事了。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom="">
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/Java/安全控制框架ApacheShiro/" title="安全控制框架ApacheShiro"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/mmzs/mmzsblog/" title="用于mmzsblog网站博客开发"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,twitter" data-mobile-sites="weibo,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan">
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan">
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope="" itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/mmzsblog" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
        &copy; 2019 mmzsblog
        
        <script type="text/javascript" src="https://s5.cnzz.com/z_stat.php?id=1275844022&web_id=1275844022"></script>
         
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: true,
    appId: 'BBUCe5DaUH5jQi1wYMQ0rTwH-gzGzoHsz',
    appKey: 'qgW4CjNI3tM14wBB9Q0R8o0k',
    placeholder: '来都来了，不说点什么',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     








</body>
</html>