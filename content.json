{"meta":{"title":"mmzsblog","subtitle":"Time is the most precious wealth of all wealth","description":"淼淼之森的博客","author":"mmzsblog","url":"https://blog.mmzsblog.cn"},"pages":[{"title":"关于","date":"2019-02-13T06:40:51.540Z","updated":"2019-02-13T06:40:51.540Z","comments":false,"path":"about/index.html","permalink":"https://blog.mmzsblog.cn/about/index.html","excerpt":"","text":"淼淼之森主要推送编程相关的知识，主要以JAVA为核心，拓展到Python大数据方向。包括分享一些基础知识、面试技巧、流行框架、数据库、前端开发技巧以及优质开源项目等。 这里只聊技术，不聊其它，因为没有比编程更纯粹的事了。快来加入我们吧！目前加入我们的有小编mmzsit和以及特邀嘉宾Alisdon、老王和小杨等。 并且我们运营了一个公众号 “淼淼之森” ；关注公众号，后台回复 “666” 更有超多惊喜等你来拿哦！"},{"title":"分类","date":"2019-02-13T06:40:51.551Z","updated":"2019-02-13T06:40:51.551Z","comments":false,"path":"categories/index.html","permalink":"https://blog.mmzsblog.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-02-13T06:40:51.572Z","updated":"2019-02-13T06:40:51.572Z","comments":true,"path":"links/index.html","permalink":"https://blog.mmzsblog.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-02-13T06:40:51.574Z","updated":"2019-02-13T06:40:51.574Z","comments":false,"path":"repository/index.html","permalink":"https://blog.mmzsblog.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-13T06:40:51.576Z","updated":"2019-02-13T06:40:51.576Z","comments":false,"path":"tags/index.html","permalink":"https://blog.mmzsblog.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring(二):Spring支持的5种Bean Scope详解","slug":"Spring之5种BeanScope","date":"2019-02-21T02:24:00.000Z","updated":"2019-02-20T09:38:13.688Z","comments":true,"path":"Spring/Spring之5种BeanScope/","link":"","permalink":"https://blog.mmzsblog.cn/Spring/Spring之5种BeanScope/","excerpt":"","text":"序言Scope是定义Spring如何创建bean的实例的。Spring容器最初提供了两种bean的scope类型：singleton和prototype,但发布2.0以后，又引入了另外三种scope类型：request、session和global session,这三种只能在web 应用中才可以使用。 在创建bean的时候可以带上scope属性，scope有下面几种类型: 概念理解Spring官方文档表示有如下5种类型： singleton：这是Spring默认的scope，表示Spring容器只创建唯一一个bean的实例，所有该对象的引用都共享这个实例，并且Spring在创建第一次后，会在Spring的IoC容器中缓存起来，之后不再创建，就是设计模式中的单例模式的形式。 并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例。一般情况下，无状态的bean使用该scope。 prototype：代表线程每次调用或请求这个bean都会创建一个新的实例。一般情况下，有状态的bean使用该scope。 request：每次http请求将会有各自的bean实例，类似于prototype。也就是说每个request作用域内的请求只创建一个实例。 session：在一个http session中，一个bean定义对应一个bean实例。也就是说每个session作用域内的请求只创建一个实例。 global session：在一个全局的http session中，一个bean定义对应一个bean实例。但是，这个scope只在porlet的web应用程序中才有意义，它映射到porlet的global范围的session，如果普通的web应用使用了这个scope，容器会把它作为普通的session作用域的scope创建。 注： 再次说明spring的默认scope（bean作用域）是singleton 使用方式创建bean的时候如何指定其作用域呢？ XML方式：1&lt; bean id = “accountService” class = “com.foo.DefaultAccountService” scope = “prototype” /&gt; 注解方式12345@Component@Scope(&quot;prototype&quot;)public class User&#123; …………&#125; 参考书籍：Spring官网：https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html","categories":[{"name":"Spring","slug":"Spring","permalink":"https://blog.mmzsblog.cn/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://blog.mmzsblog.cn/tags/spring/"}]},{"title":"Spring(一):IoC容器的理解","slug":"Spring之IoC容器理解","date":"2019-02-20T02:24:00.000Z","updated":"2019-02-20T09:40:26.802Z","comments":true,"path":"Spring/Spring之IoC容器理解/","link":"","permalink":"https://blog.mmzsblog.cn/Spring/Spring之IoC容器理解/","excerpt":"","text":"序言记得刚毕业那会儿，出来招工作被问到Spring的核心时，都觉得简单的一笔，直接说不就是控制反转和依赖注入么，然后省略一万字对两个名词的解释。最近空来整理了一下Spring中IoC的相关概念，即是复习，也是希望分享出来能帮助到大家更快理解IoC。 其实IoC包括依赖查找(DL)和依赖注入(DI)；只不过DL因为有侵入性 (它需要用户自己去是使用 API 进行查找资源和组装对象)，已经被抛弃。所以现在提到IoC，更多的想到的就是依赖注入(DI)了。 依赖注入(DI)包括Set注入和构造器注入！如图所示： IoC粗理解IoC亦称为“依赖倒置原理”（Dependency Inversion Principle),几乎所有框架都使用了倒置注入（Martin Fowler)技巧，是IoC原理的一项应用。SmaIITaIk、C++、Java和.NET面向对象语言的程序员已使用了这些原理。但是Spring是Java语言实现中最著名的一个。同时，控制反转即是Sprrng框架的核心，也是Spring框架要解决的核心问题。 IoC细理解由于很多对象的依赖关系和维护并不需要和系统运行状态有很强的关联性，所以可以把在面向对象编程中需要执行的诸如新建对象、为对象引用赋值等操作交由容器统一完成；这样一来，这些散落在不同代码中的功能相同的部分就集中成为容器的一部分，也就是面向对象系统的基础设施的一部分。同时，由于这些对象之间的相互依赖关系也是比较稳定的，一般不会随着应用的运行状态的改变而改变。 基于以上特性，这些对象使用IoC容器来管理，简直就是天作之合。虽然这些特性存在于应用系统中，但是应用系统并不承担管理这些对象的责任，而是通过依赖反转把责任交给了容器（也可以说是平台）。 有了以上这些基础知识储备，Spring IoC容器的原理也就不难理解了。 Spring中IoC的应用在Spring中，Spring IoC提供了一个基本的JavaBean容器，通过IoC模式管理依赖关系，并通过依赖注入和AOP切面增强了为JavaBea月这样的POJO对象赋予事务管理、生命周期管理等基本功能。 IoC容器容器的两种表现形式Spring 作者 Rod Johnson设计了两个接口用以表示容器：BeanFactory和ApplicationContext BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。 ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。 故我们可以认为直接的BeanFactory实现是IoC容器的基本形式，而各种ApplicationContext的实现是IoC容器的高级表现形式。所以亦可简单的把Spring IoC通过BeanFactory的实现当做低级容器；把ApplicationContext的实现当做高级容器。 此文我们主要讲解Spring 低级容器（BeanFactory）的 IoC；因为高级容器 ApplicationContext，它包含了低级容器的功能，当它执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，它包含了太多的功能，不仅仅是 IoC。它支持不同信息源头，支持 BeanFactory 工具类、支持层级容器、支持访问文件资源、支持事件发布通知、支持接口回调等等。 图片来源:《Spring技术内幕：深入解析Spring架构与设计原理(第2版)》 BeanFactory的IoC实现过程：IoC 在 Spring 里，只需要低级容器（BeanFactory）就可以实现，两个步骤： 1、加载配置文件，解析成 BeanDefinition 放在 Map 里。 2、调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。getBean的流程如下所示： IoC容器初始化过程值得注意的是，在这个过程中，一般不包含Bean侬赖注人的实现。 在Spring IoC的设计中，Bean定义的载入和依赖注入是两个独立的过程。依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候。 但有一个例外值得注意，在使用loc容器时有一个预实例化的配置，通过这个预实例化的配置（具体来说，可以通过为Bean定义信息中的lazyinit属性),用户可以对容器初始化过程作一个微小的控制，从而改变这个被设置了]azyinit属性的Bean的依赖注入过程。 举例来说，如果我们对某个Bean设置了lazyinit属性，那么这个Bean的依赖注人在IoC容器初始化时就预先完成了，而不需要等到整个初始化完成以后，第一次使用getBean时才会触发。 BeanDefinition的定位对loC容器来说，它为管理POJO之间的依赖关系提供了帮助，但也要依据Spring的定义规则提供Bean定义信息。我们可以使用各种形式的Bean定义信息，其中比较熟悉和常用的是使用XML的文件格式。 在Bean定义方面，Spring为用户提供了很大的灵活性。在初始化IoC容器的过程中，首先需要定位到这些有效的Bean定义信息，这里Spring使用Resource接口来统一这些Bean定义信息，而这个定位由ResourceLoader来完成。 如果使用上下文，ApplicationContext本身就为客户提供了定位的功能。因为上下文本身就是DefaultResourceLoader的子类。 如果使用基本的BeanFactory作为loC容器，客户需要做的额外工作就是为BeanFactory指定相应的Resource来完成Bean信息的定位。 BeanDefinition的载入信息的载入过程。对IoC容器来说，这个载入过程，相当于把定义的BeanDefinition在IoC容器中转化成一个spring内部表示的数据结构的过程。IoC容器对Bean的管理和依赖注人功能的实现，都是通过对其持有的BeanDefinition进行各种相关操作来完成的。这些BeanDefinition数据在IoC容器中通过一个HashMap来保持和维护。当然这只是一种比较简单的维护方式，如果需要提高IoC容器的性能和容量，完全可以自己做一些扩展。 IoC容器的依赖注入IoC容器的初始化过程完成的主要工作是在IoC容器中建立BeanDefinition数据映射。但在此过程中并没有IoC容器对Bean依赖关系进行注入，那么IoC容器是怎样对Bean的依赖关系进行注人的呢？ 假设当前IoC容器已经载入了用户定义的Bean信息，开始分析依赖注人的原理：首先，依赖注入的过程是用户第一次向容器索要Bean时触发的，当然也有例外，也就是我们可以在BeanDefinition信息中通过控制lazy-init属性来让容器完成对Bean的预实例化。这个预实例化实际上也是一个完成依赖注入的过程，但它是在初始化的过程中完成的。 所以，当用户向IoC容器索要Bean时，如果读者还有印象，那么一定还记得在基本的IoC容器接口BeanFactory中，有一个getBean的接口定义，这个接口的实现就是触发依赖注入发生的地方(也就是依赖注入的入口)；而依赖注入的发生是在容器中的BeanDefinition数据已经建立好的前提下才能完成的。 IoC小结尽管可以用最简单的方式来描述IoC容器，将它视为一个hashMap，但只能说这个hashMap是容器的最基本的数据结构，而不是IoC容器的全部。Spring IoC容器作为一个产品，其价值体现在一系列相关的产品特性上，这些产品特性以依赖反转模式的实现为核心，为用户更好地使用依赖反转提供便利，从而实现了一个完整的IoC容器产品。这些产品特性的实现并不是一个 参考书籍： 1、《Spring技术内幕：深入解析Spring架构与设计原理(第2版)》 2、https://www.cnblogs.com/stateis0/p/9779011.html","categories":[{"name":"Spring","slug":"Spring","permalink":"https://blog.mmzsblog.cn/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://blog.mmzsblog.cn/tags/spring/"}]},{"title":"git提交报错，提示文件过大，且去掉大文件也报同样的错误","slug":"git提交大文件报错","date":"2019-02-19T10:16:19.000Z","updated":"2019-02-19T07:05:33.825Z","comments":true,"path":"DevelopmentTools/git提交大文件报错/","link":"","permalink":"https://blog.mmzsblog.cn/DevelopmentTools/git提交大文件报错/","excerpt":"","text":"错误原因：大文件存在没有被提交的commit记录里面； 解决方案：删除有大文件的commit记录即可 移除大文件的正确姿势1234$ git rm --cached giant_file（文件名） # Stage our giant file for removal, but leave it on disk $ git commit --amend -CHEAD $ git push 解法一：以下操作完后，相当于把本地代码回滚到远端的代码一致；的远端代码文件过大时，此种方式比从远端重新拉取方便快捷123git fetch -f -pgit checkout devgit reset origin/dev --hard 第一句代码git fetch -f -p的作用就是从本地拿到远程最新分支，覆盖本地存放的远程分支 第二句实际上因为主要开发分支就是 dev 分支，小伙伴就是把大文件合并到这个分支，所以需要切换到这个分支。如果你不小心把大文件提交其它的分支，记得切换的就是你提交的分支。如果提交大文件只是在自己的分支，并且放到了远程分支，那么合并到远程开发分支，那么只需要删除自己远程分支就好了，不需要继续往下做。 第三句git reset origin/dev --hard是把自己的本地 dev 分支覆盖，使用远程的分支，如果开发分支不是 dev ，那么请用其它的分支。 解法二：网友：https://blog.csdn.net/m0_37696127/article/details/78984216分享的，不过我试了后没解决问题，但是也分享一下。 1、git status 查看未被传送到远程代码库的提交次数 2、git cherry -v 查看未被传送到远程代码库的提交描述和说明 3、git reset commit_id 撤销未被传送到远程代码库的提交做到这里就已经可以重新添加提交了（注意一定要撤销有大文件的提交）","categories":[{"name":"DevelopmentTools","slug":"DevelopmentTools","permalink":"https://blog.mmzsblog.cn/categories/DevelopmentTools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.mmzsblog.cn/tags/git/"}]},{"title":"Hexo优化：创建sitemap站点地图并向google提交","slug":"addGoogleSitemap","date":"2019-02-14T03:15:33.000Z","updated":"2019-02-14T03:30:44.449Z","comments":true,"path":"mmzs/addGoogleSitemap/","link":"","permalink":"https://blog.mmzsblog.cn/mmzs/addGoogleSitemap/","excerpt":"","text":"前言站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Sitemap 可方便管理员通知搜索引擎他们网站上有哪些可供抓取的网页。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 而向google提交自己hexo博客的sitemap有助于让别人更好地通过google搜索到自己的博客。 具体步骤:第一步: 生成自己的sitemap文件先安装一下自动生成插件，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 进入博客根目录下，打开_config.yml文件，在最后一行添加如下代码:123456789# 谷歌、百度站点地图生成Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在终端执行以下代码：打包编译：hexo g发布提交：hexo d 重新部署代码（部署到github服务器的情况）然后在浏览器输入 你的域名／sitemap.xml例如：http://mmzsblog.github.io/blog/sitemap.xml就能看到生成的xml文件；并且在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了。 第二步：按照提示进行网页验证点这里进行操作：https://search.google.com/search-console 第三步：添加站点地图可点击如下链接操作：https://www.google.com/webmasters/tools/sitemap-list大概需要等待一天左右，再进入这个页面，就能看到google已经搜录的页面了。","categories":[{"name":"mmzs","slug":"mmzs","permalink":"https://blog.mmzsblog.cn/categories/mmzs/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.mmzsblog.cn/tags/hexo/"}]},{"title":"IDEA开发插件推荐","slug":"IDEA开发插件推荐","date":"2019-01-09T04:55:04.000Z","updated":"2019-02-14T03:48:41.248Z","comments":true,"path":"DevelopmentTools/IDEA开发插件推荐/","link":"","permalink":"https://blog.mmzsblog.cn/DevelopmentTools/IDEA开发插件推荐/","excerpt":"","text":"实用离线下载地址： https://plugins.jetbrains.com alibba java coding guidelines 这是阿里巴巴代码检测插件，有了它，再也不用担心代码不规范了，因为有它一直在监视你的代码规范，为你纠正和提示！ FindBugs-IDEA 检测代码中可能的bug及不规范的位置，检测的模式相比p3c更多，写完代码后检测下避免低级bug，强烈建议用一下，一不小心就发现很多老代码的bug Lombok plugin 实体类开发神器，可以简化你的实体类，让你i不再写get/set方法，还能快速的实现builder模式，以及链式调用方法，总之就是为了简化实体类而生的插件。 CamelCase 将不是驼峰格式的命名自动转化驼峰；快捷键：shift+alt+u` Mybatis plugin 可以在mapper接口中和mapper的xml文件中来回跳转，就想接口跳到实现类那样简单。 Rainbow Brackets 彩虹颜色的括号，看着很舒服，能清晰的配对左右括号，敲代码效率变高 JRebel for IntelliJ 一款热部署插件，只要不是修改了项目的配置文件，用它都可以实现热部署。收费的，破解比较麻烦。不过功能确实很强大。算是开发必备神器了。热部署快捷键是control+F9/command+F9。 .ignore git提交时过滤掉不需要提交的文件，很方便，有些本地文件是不需要提交到Git上的。 Maven Helper 一键查看maven依赖，查看冲突的依赖，一键进行exclude依赖对于大型项目非常方便 MyBatisCodeHelperPro mybatis代码自动生成插件，大部分单表操作的代码可自动生成 减少重复劳动 大幅提升效率 装逼 CodeGlance 在编辑区的右侧显示的代码地图，方便快速定位。 Material Theme UI 这是一款主题插件，可以让你的ide的图标变漂亮，配色搭配的很到位，还可以切换不同的颜色，甚至可以自定义颜色。默认的配色就很漂亮了，如果需要修改配色，可以在工具栏中Tools-&gt;Material Theme然后修改配色等。 Background image Plus 这是一款可以设置idea背景图片的插件，不但可以设置固体的图片，还可以设置一段时间后随机变化背景图片，以及设置图片的透明度等等。 activate-power-mode 这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。可以在工具栏Window-&gt;activate-power-mode进行设置。 Translation 最好用的翻译插件，功能很强大，界面很漂亮 Nyan progress bar 这是一个将你idea中的所有的进度条都变成萌新动画的小插件。这款插件较大，内存不是很充足的话，慎用！ 其它 VisualVM Launcher 运行java程序的时候启动visualvm，方便查看jvm的情况 比如堆内存大小的分配；某个对象占用了多大的内存，jvm调优必备工具 codehelper.generator 可以让你在创建一个对象并赋值的时候，快速的生成代码，不需要一个一个属性的向里面set,根据new关键字，自动生成掉用set方法的代码，还可以一键填入默认值。 GenerateAllSetter 一键调用一个对象的所有set方法并且赋予默认值 在对象字段多的时候非常方便，在做项目时，每层都有各自的实体对象需要相互转换，但是考虑BeanUtil.copyProperties()等这些工具的弊端，有些地方就需要手动的赋值时，有这个插件就会很方便，创建完对象后在变量名上面按Alt+Enter就会出来 generate all setter选项。","categories":[{"name":"DevelopmentTools","slug":"DevelopmentTools","permalink":"https://blog.mmzsblog.cn/categories/DevelopmentTools/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://blog.mmzsblog.cn/tags/idea/"}]},{"title":"一文详解集合的不同之处","slug":"一文详解集合的不同之处","date":"2019-01-04T04:40:48.000Z","updated":"2019-02-13T06:40:51.481Z","comments":true,"path":"Java/一文详解集合的不同之处/","link":"","permalink":"https://blog.mmzsblog.cn/Java/一文详解集合的不同之处/","excerpt":"","text":"序言集合这个东西吧，说简单也简单，但是你想把它用溜呢，也还是需要下点功夫的。 Collection分两种：List元素是有序的，元素可以重复，因为该集合体有索引 ArrayList: 底层数据结构是数组，查询快，增删慢。 线程不安全，效率高。 当元素放满了后，默认以原长度的50%+1的长度加长集合容器的长度。Vector: 底层数据结构是数组，查询快，增删慢。 线程安全，效率低。 当元素放满了后，默认以原长度100%的长度加长集合容器的长度LinkedList: 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高。 Vector(线程安全的)相对ArrayList查询慢 Vector相对LinkedList增删慢(数组结构)Set：元素是无序的，元素不可以重复。 a)、HashSet：不能保证元素的排列顺序，线程不同步。 b)、TreeSet：可以set集合中的元素进行排序，线程不同步。 使用注意事项：使用Vector举例：12345678910111213141516171819202122232425262728293031323334353637383940414243public class VectorDemo &#123; public static void main(String[] args) &#123; testone(); testtwo(); &#125; public static void testone() &#123; // 初始大小为3；自动扩容增量为2 Vector v = new Vector(3, 2); System.out.println(\"初始化大小: \" + v.size()); System.out.println(\"初始化容量: \" + v.capacity()); v.addElement(new String(\"one\")); v.addElement(new Integer(1)); v.addElement(new Integer(2)); v.addElement(new Integer(3)); System.out.println(\"增加4个元素后的容量: \" + v.capacity()); Enumeration vEnum = v.elements(); while(vEnum.hasMoreElements()) //依次输出Vector数组中的元素 System.out.print(vEnum.nextElement() + \" \"); System.out.println(); &#125; public static void testtwo() &#123; // 初始大小为3；默认自动扩容增量100%，此处即为3 Vector v = new Vector(3); System.out.println(\"初始化大小: \" + v.size()); System.out.println(\"初始化容量: \" + v.capacity()); v.addElement(new String(\"two\")); v.addElement(new Integer(2)); v.addElement(new Integer(3)); v.addElement(new Integer(4)); System.out.println(\"增加4个元素后的容量: \" + v.capacity()); Enumeration vEnum = v.elements(); while(vEnum.hasMoreElements()) //依次输出Vector数组中的元素 System.out.print(vEnum.nextElement() + \" \"); System.out.println(); &#125;&#125; 使用List举例问题：12345678List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(\"1\");list.add(\"2\");for (String item : list) &#123; if (\"1\".equals(item)) &#123; list.remove(item); &#125;&#125; 1)请问上述操作如何？ 2)若把list.remove(item)换成list.add(“3”);操作如何？ 3)若在第6行添加list.add(“3”);那么代码会出错吗？ 4)若把if语句中的“1”换成“2”，结果你感到意外吗？ 运行结果：1)没错，后面2)3)4)都会报ConcurrentModificationException的异常； 注意： 不要在foreach 循环里进行元素的remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对Iterator对象加锁。 二者本质是一样的，都是通过Iterator迭代器来实现的遍历，foreach是增强版的for循环，可以看作是如下方式二的简化形式：1234567Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; //方式二String item = iterator.next(); if (删除元素的条件) &#123; iterator.remove(); &#125;&#125; 首先，这涉及多线程操作，Iterator是不支持多线程操作的，List类会在内部维护一个modCount的变量，用来记录修改次数 举例：ArrayList源码1protected transient int modCount = 0; 每生成一个Iterator，Iterator就会记录该modCount，每次调用next()方法就会将该记录与外部类List的modCount进行对比，发现不相等就会抛出多线程编辑异常。 为什么这么做呢？我的理解是你创建了一个迭代器，该迭代器和要遍历的集合的内容是紧耦合的，意思就是这个迭代器对应的集合内容就是当前的内容，我肯定不会希望在我冒泡排序的时候，还有线程在向我的集合里插入数据对吧？所以Java用了这种简单的处理机制来禁止遍历时修改集合。 至于为什么删除“1”就可以呢，原因在于foreach和迭代器的hasNext()方法，foreach这个语法，实际上就是123while(itr.hasNext())&#123; itr.next()&#125; 所以每次循环都会先执行hasNext()，那么看看ArrayList的hasNext()是怎么写的：123public boolean hasNext() &#123; return cursor != size;&#125; cursor是用于标记迭代器位置的变量，该变量由0开始，每次调用next执行+1操作，于是： 你的代码在执行删除“1”后，size=1，cursor=1，此时hasNext()返回false，结束循环，因此你的迭代器并没有调用next查找第二个元素，也就无从检测modCount了，因此也不会出现多线程修改异常；但当你删除“2”时，迭代器调用了两次next，此时size=1，cursor=2，hasNext()返回true，于是迭代器傻乎乎的就又去调用了一次next()，因此也引发了modCount不相等，抛出多线程修改的异常。 当你的集合有三个元素的时候，你就会神奇的发现，删除“1”是会抛出异常的，但删除“2”就没有问题了，究其原因，和上面的程序执行顺序是一致的.","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://blog.mmzsblog.cn/tags/集合/"}]},{"title":"2018年终总结","slug":"2018年终总结","date":"2018-12-31T15:59:59.000Z","updated":"2019-02-14T03:48:58.724Z","comments":true,"path":"ProgramLife/2018年终总结/","link":"","permalink":"https://blog.mmzsblog.cn/ProgramLife/2018年终总结/","excerpt":"","text":"2018年将逝，虽然我之前一直在其他平台更新自己的文章，一开始是博客园，主要是因为博客园的界面啊啥的都能自定义，能找到自己想要的风格，但是还从来没有写过年终总结，今年也就趁着做公众号的这个缝隙，跟大家聊聊这一年在工作和生活中的感悟吧。 首先让我感到收获最大的一件事估计就是做公众认识了很多人，感谢大家的支持，让我一直坚持写作，写作其实也是一个总结的过程，之前在博客园写文章就只是单纯的当做一种记录，记录自己在开发中遇到的困惑、收获之类的，不过都是用心写的文章，实战偏多。但在公众号写文章的时候你会思考如何让文章写的更加浅显易懂，如何吸引粉丝，如何了解粉丝想看的内容，哪些又不适合。所以呀，其实写作也是一个技术活，就比如公众号“程序员小灰”吧，别人能用不一样的方式来讲解技术，着实是一着妙棋，后面也有很多公众号跟风写这类文章，但是我依然觉得小灰的写的才是最有意思的，也许这就是先入为主的思想吧。所以公众号写作和运营也是在考验着你的创新思维。 2018年5月20日申请公众号，加入这个行列之后，正式更文在8月份，一路上收获颇多，新的一年还请大家多多关照。毕竟开始做公众号之前的我也和大家想的一样，不就是每天更新几篇文章就好了么？可事实是，你需要不停地输入才能有输出，不然总是会坐吃山空的。而且还有很多运营技巧和营销手段等着我去领悟。所以啊，我在极客时间买了一份“产品实战”的课程学习，看完后也是总结了很多技巧和知识。 2018自己开拓视野似的学习了很多非技术相关的知识；那么在2019，我将会更多的将学习时间分配给技术，毕竟学无止境，作为一个技术人员，只有将自己的技术硬实力提升才能更好的为公众号输出更多优秀优质的文章；当然，这只是我给自己的2019学习方向。 如果你年初立的flag很多，实现的却寥寥无几；可能你会焦虑，可能你也会为自己找一个借口，但是只要你认真的朝着flag努力了；当2018年底时，回头看自己走过的路，能对自己问心无愧的说一句：我把自己的时间都奉献给了flag，那就够了。","categories":[{"name":"ProgramLife","slug":"ProgramLife","permalink":"https://blog.mmzsblog.cn/categories/ProgramLife/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://blog.mmzsblog.cn/tags/年终总结/"}]},{"title":"玩转SpringBoot之定时任务详解","slug":"玩转SpringBoot之定时任务详解","date":"2018-12-21T07:13:29.000Z","updated":"2019-02-14T03:43:54.624Z","comments":true,"path":"SpringBoot/玩转SpringBoot之定时任务详解/","link":"","permalink":"https://blog.mmzsblog.cn/SpringBoot/玩转SpringBoot之定时任务详解/","excerpt":"","text":"序言使用SpringBoot创建定时任务非常简单，目前主要有以下两种创建方式： 一、基于注解(@Scheduled) 二、基于接口（SchedulingConfigurer） 前者相信大家都很熟悉，但是实际使用中我们往往想从数据库中读取指定时间来动态执行定时任务，这时候基于接口的定时任务就派上用场了。 三、基于注解设定多线程定时任务静态：基于注解基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。创建定时器使用SpringBoot基于注解来创建定时任务非常简单，只需几行代码便可完成。代码如下：123456789101112@Component@Configuration //1.主要用于标记配置类，兼备Component的效果。@EnableScheduling // 2.开启定时任务public class SaticScheduleTask &#123; //3.添加定时任务 @Scheduled(cron = \"0/5 * * * * ?\") //或直接指定时间间隔，例如：5秒 //@Scheduled(fixedRate=5000) private void configureTasks() &#123; System.err.println(\"执行静态定时任务时间: \" + LocalDateTime.now()); &#125;&#125; Cron表达式参数分别表示： 秒（0~59） 例如0/5表示每5秒 分（0~59） 时（0~23） 日（0~31）的某天，需计算 月（0~11） 周几（ 可填1-7 或 SUN/MON/TUE/WED/THU/FRI/SAT） @Scheduled：除了支持灵活的参数表达式cron之外，还支持简单的延时操作，例如 fixedDelay ，fixedRate 填写相应的毫秒数即可。 启动测试启动应用，可以看到控制台打印出如下信息：显然，使用@Scheduled注解很方便，但缺点是当我们调整了执行周期的时候，需要重启应用才能生效，这多少有些不方便。为了达到实时生效的效果，可以使用接口来完成定时任务。 动态：基于接口基于接口（SchedulingConfigurer） 导入依赖包：123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt;&lt;!--添加Web依赖 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!--添加MySql依赖 --&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!--添加Mybatis依赖 配置mybatis的一些初始化的东西--&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 添加mybatis依赖 --&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加数据库记录：开启本地数据库mysql，随便打开查询窗口，然后执行脚本内容，如下：123456789DROP DATABASE IF EXISTS `socks`;CREATE DATABASE `socks`;USE `SOCKS`;DROP TABLE IF EXISTS `cron`;CREATE TABLE `cron` ( `cron_id` varchar(30) NOT NULL PRIMARY KEY, `cron` varchar(30) NOT NULL );INSERT INTO `cron` VALUES ('1', '0/5 * * * * ?'); 然后在项目中的application.yml添加数据源：12345spring: datasource: url: jdbc:mysql://localhost:3306/socks username: root password: 123456 创建定时器数据库准备好数据之后，我们编写定时任务，注意这里添加的是TriggerTask，目的是循环读取我们在数据库设置好的执行周期，以及执行相关定时任务的内容。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839@Component@Configuration //1.主要用于标记配置类，兼备Component的效果。@EnableScheduling // 2.开启定时任务public class DynamicScheduleTask implements SchedulingConfigurer &#123; @Mapper public interface CronMapper &#123; @Select(\"select cron from cron limit 1\") public String getCron(); &#125; @Autowired //注入mapper @SuppressWarnings(\"all\") CronMapper cronMapper; /** * 执行定时任务. */ @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.addTriggerTask( //1.添加任务内容(Runnable) () -&gt; System.out.println(\"执行动态定时任务: \" + LocalDateTime.now().toLocalTime()), //2.设置执行周期(Trigger) triggerContext -&gt; &#123; //2.1 从数据库获取执行周期 String cron = cronMapper.getCron(); //2.2 合法性校验. if (StringUtils.isEmpty(cron)) &#123; // Omitted Code .. &#125; //2.3 返回执行周期(Date) return new CronTrigger(cron).nextExecutionTime(triggerContext); &#125; ); &#125;&#125; 启动测试启动应用后，查看控制台，打印时间是我们预期的每10秒一次：然后打开Navicat ，将执行周期修改为每6秒执行一次，如图：查看控制台，发现执行周期已经改变，并且不需要我们重启应用，十分方便。如图：==注意：== 如果在数据库修改时格式出现错误，则定时任务会停止，即使重新修改正确；此时只能重新启动项目才能恢复。 多线程基于注解设定多线程定时任务 创建多线程定时任务12345678910111213141516171819202122//@Component注解用于对那些比较中立的类进行注释；//相对与在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释@Component@EnableScheduling // 1.开启定时任务@EnableAsync // 2.开启多线程public class MultithreadScheduleTask &#123; @Async @Scheduled(fixedDelay = 1000) //间隔1秒 public void first() throws InterruptedException &#123; System.out.println(\"第一个定时任务开始 : \" + LocalDateTime.now().toLocalTime() + \"\\r\\n线程 : \" + Thread.currentThread().getName()); System.out.println(); Thread.sleep(1000 * 10); &#125; @Async @Scheduled(fixedDelay = 2000) public void second() &#123; System.out.println(\"第二个定时任务开始 : \" + LocalDateTime.now().toLocalTime() + \"\\r\\n线程 : \" + Thread.currentThread().getName()); System.out.println(); &#125; &#125; 启动测试启动应用后，查看控制台：从控制台可以看出，第一个定时任务和第二个定时任务互不影响； 并且，由于开启了多线程，第一个任务的执行时间也不受其本身执行时间的限制，所以需要注意可能会出现重复操作导致数据异常。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.mmzsblog.cn/categories/SpringBoot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.mmzsblog.cn/tags/springboot/"}]},{"title":"创建简单的npm脚手架","slug":"创建简单的npm脚手架","date":"2018-12-18T08:57:18.000Z","updated":"2019-02-14T03:41:08.177Z","comments":true,"path":"Node/创建简单的npm脚手架/","link":"","permalink":"https://blog.mmzsblog.cn/Node/创建简单的npm脚手架/","excerpt":"","text":"前言vue-cli， webpack-cli 等脚手架是不是用起来爱不释手？自己写了个模版每次来回复制粘贴代码是不是很难维护？如果你是对前端、Node操作有一定的了解，同时也存在以上疑问，那就请尽情阅读尝试吧！ 本篇文章按照al-block-cli举例, al-block-cli是一个基于vue和elementUI而集成的一个开发模版，可安装进行使用 依赖 Commander.js 命令行工具 download-git-repo git仓库代码下载 chalk 命令行输出样式美化 Inquirer.js 命令行交互 ora命令行加载中效果 根据上方的依赖插件即可以看出，其实脚手架就是一个利用终端命令将仓库中的代码拉取到本地的工具。所以还没有模版代码的同学赶紧去创建个 项目准备初始化1$ npm init 根据提示完成初始化搭建，如果不清楚如何配置可以直接回车 安装依赖1$ npm install commander download-git-repo chalk inquirer ora --save 构建结构创建bin和commands文件夹以及配置文件templates.json。bin文件夹为可执行命令入口目录，commands则负责编写一些命令交互 最终目录结构123456- al-block-cli| - bin| - commands| - node_modules| - package.json| - templates.json 编写代码配置文件输入默认需要的配置，如这里需要github的仓库地址和命令行的名称 123456&#123; &quot;init&quot;: &#123; &quot;name&quot;: &quot;init&quot;, &quot;path&quot;: &quot;Alisdon/al-block-template&quot; &#125;&#125; 入口文件新建al-block-cli文件，并在其第一行加入 1#! /usr/bin/env node 此行为了防止操作系统用户没有将node装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。 123456789101112131415161718192021222324#!/usr/bin/env nodeprocess.env.NODE_PATH = __dirname + &apos;/../node_modules/&apos;;const program = require(&apos;commander&apos;);program .version(require(&apos;../package&apos;).version);program .usage(&apos;&lt;command&gt;&apos;);program.command(&apos;init&apos;) .description(&apos;create a new project&apos;) .alias(&apos;i&apos;) .action(() =&gt; &#123; require(&apos;../commands/init&apos;) &#125;);program.parse(process.argv);if(!program.args.length)&#123; program.help()&#125; 命令交互新建init.js文件表示命令init 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const &#123; prompt &#125; = require(&apos;inquirer&apos;);const program = require(&apos;commander&apos;);const chalk = require(&apos;chalk&apos;);const download = require(&apos;download-git-repo&apos;);const ora = require(&apos;ora&apos;);const fs = require(&apos;fs&apos;);const option = program.parse(process.argv).args[0];const question = [ &#123; type: &apos;input&apos;, name: &apos;name&apos;, message: &apos;Project name&apos;, default: typeof option === &apos;string&apos; ? option : &apos;al-block-template&apos;, filter (val) &#123; return val.trim() &#125;, validate (val) &#123; const validate = (val.trim().split(&quot; &quot;)).length === 1; return validate || &apos;Project name is not allowed to have spaces &apos;; &#125;, transformer (val) &#123; return val; &#125; &#125;, &#123; type: &apos;input&apos;, name: &apos;description&apos;, message: &apos;Project description&apos;, default: &apos;Vue project&apos;, validate () &#123; return true; &#125;, transformer(val) &#123; return val; &#125; &#125;, &#123; type: &apos;input&apos;, name: &apos;author&apos;, message: &apos;Author&apos;, default: &apos;&apos;, validate () &#123; return true; &#125;, transformer(val) &#123; return val; &#125; &#125;];module.exports = prompt(question).then((&#123;name, description, author&#125;) =&gt; &#123; const gitPlace = require(&apos;../templates&apos;).init.path; const projectName = name; const spinner = ora(&apos;Downloading please wait...&apos;); spinner.start(); download(`$&#123;gitPlace&#125;`, `./$&#123;projectName&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(chalk.red(err)); process.exit() &#125; fs.readFile(`./$&#123;projectName&#125;/package.json`, &apos;utf8&apos;, function (err, data) &#123; if(err) &#123; spinner.stop(); console.error(err); return; &#125; const packageJson = JSON.parse(data); packageJson.name = name; packageJson.description = description; packageJson.author = author; fs.writeFile(`./$&#123;projectName&#125;/package.json`, JSON.stringify(packageJson, null, 2), &apos;utf8&apos;, function (err) &#123; if(err) &#123; spinner.stop(); console.error(err); &#125; else &#123; spinner.stop(); console.log(chalk.green(&apos;project init successfully!&apos;)) console.log(` $&#123;chalk.yellow(`cd $&#123;name&#125;`)&#125; $&#123;chalk.yellow(&apos;npm install&apos;)&#125; $&#123;chalk.yellow(&apos;npm run dev&apos;)&#125; `); &#125; &#125;); &#125;); &#125;)&#125;); 测试发布测试至此，一个简单的脚手架（壳）就已经完成了，为了查看在编写过程中是否出错，我们现在本地进行测试 1$ node bin/al-block-cli 如果没有报错，出现了熟悉的命令行，那就说明成功了 发布发布之前我们需要做个小调整，观察其他脚手架工具他们都是以自己独特的key值进行搭建，对此我们可以在package.json里面配置bin对象 123&quot;bin&quot;: &#123; &quot;al-block-cli&quot;: &quot;bin/al-block-cli&quot;&#125; 这里需要注意bin/后面的al-block-cli,这个路径是由入口文件的路径确定，如果你是建的al-block-cli.js则此处应该配置bin/al-block-cli.js，本篇是创建的没有后缀名的文件 修改后生成的最终package.json 1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;al-block-cli&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;al-block-cli&quot;, &quot;keywords&quot;: [ &quot;vue&quot;, &quot;al-block&quot;, &quot;al-block-cli&quot; ], &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;bin&quot;: &#123; &quot;al-block-cli&quot;: &quot;bin/al-block-cli&quot; &#125;, &quot;preferGlobal&quot;: true, &quot;author&quot;: &quot;Alisdon [920124512@qq.com]&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;chalk&quot;: &quot;^2.4.1&quot;, &quot;commander&quot;: &quot;^2.19.0&quot;, &quot;download-git-repo&quot;: &quot;^1.1.0&quot;, &quot;inquirer&quot;: &quot;^6.2.1&quot;, &quot;ora&quot;: &quot;^3.0.0&quot; &#125;&#125; 对比文件内容，如果没有问题我们就开始发布了 12$ npm login$ npm publish","categories":[{"name":"Node","slug":"Node","permalink":"https://blog.mmzsblog.cn/categories/Node/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://blog.mmzsblog.cn/tags/npm/"}]},{"title":"利用SHA-1算法和RSA秘钥进行签名验签","slug":"利用SHA-1算法和RSA秘钥进行签名验签","date":"2018-12-17T09:13:12.000Z","updated":"2019-02-13T06:40:51.486Z","comments":true,"path":"Java/利用SHA-1算法和RSA秘钥进行签名验签/","link":"","permalink":"https://blog.mmzsblog.cn/Java/利用SHA-1算法和RSA秘钥进行签名验签/","excerpt":"","text":"背景介绍SHA安全散列算法SHA (Secure Hash Algorithm)是美国国家标准和技术局发布的国家标准FIPS PUB 180-1，一般称为SHA-1。其对长度不超过264二进制位的消息产生160位的消息摘要输出，按512比特块处理其输入。 SHA是一种数据加密算法，该算法经过加密专家多年来的发展和改进已日益完善，现在已成为公认的最安全的散列算法之一，并被广泛使用。 该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说时对明文的一种“指纹”或是“摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。 消息摘要定义：消息摘要（Message Digest）又称为数字摘要(Digital Digest)。它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash加密函数对消息进行作用而产生。如果消息在途中改变了，则接收者通过对收到消息的新产生的摘要与原摘要比较，就可知道消息是否被改变了。因此消息摘要保证了消息的完整性。 消息摘要采用单向Hash函数将需加密的明文”摘要”成一串128bit的密文，这一串密文亦称为数字指纹(Finger Print)，它有固定的长度，且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是”真身”的”指纹”了。 类型：摘要：GOST3411，Keccak，MD2，MD4，MD5，RIPEMD128，RIPEMD160，RIPEMD256，RIPEMD320，SHA-1，SHA-224，SHA-256，SHA-384，SHA-512，SHA3，Tiger和Whirlpool。 公钥和私钥：定义：公钥和私钥就是俗称的不对称加密方式，是从以前的对称加密（使用用户名与密码）方式的提高。 下面用电子邮件的方式说明一下原理：使用公钥与私钥的目的就是实现安全的电子邮件，必须实现如下目的： 1、我发送给你的内容必须加密，在邮件的传输过程中不能被别人看到。 2、必须保证是我发送的邮件，不是别人冒充我的。要达到这样的目标必须发送邮件的两人都有公钥和私钥。 公钥: 就是给大家用的，你可以通过电子邮件发布，可以通过网站让别人下载，公钥其实是用来加密/验章用的。 私钥: 就是自己的，必须非常小心保存，最好加上密码，私钥是用来解密/签章，首先就Key的所有权来说，私钥只有个人拥有。 公钥与私钥的作用是： 用公钥加密的内容只能用私钥解密，用私钥加密的内容只能用公钥解密。 举例： 比如说，我要给你发送一个加密的邮件。首先，我必须拥有你的公钥，你也必须拥有我的公钥。 首先，我用你的公钥给这个邮件加密，这样就保证这个邮件不被别人看到，而且保证这个邮件在传送过程中没有被修改。你收到邮件后，用你的私钥就可以解密，就能看到内容。 其次我用我的私钥给这个邮件加密，发送到你手里后，你可以用我的公钥解密。因为私钥只有我手里有，这样就保证了这个邮件是我发送的。 当A-&gt;B资料时，A会使用B的公钥加密，这样才能确保只有B能解开，否则普罗大众都能解开加密的讯息，就是去了资料的保密性。验证方面则是使用签验章的机制，A传资料给大家时，会以自己的私钥做签章，如此所有收到讯息的人都可以用A的公钥进行验章，便可确认讯息是由A发出来的了。类型： 对称密钥算法： AES, Blowfish, Camellia, CAST5, CAST6,ChaCha, DES, DESede, GOST28147, HC-128, HC-256, IDEA, ISAAC, Noekeon, RC2, RC4, RC5-32, RC5-64, RC6, Rijndael, Salsa20, SEED, Serpent, Skipjack, TEA/XTEA, Threefish, Tnepres, Twofish, VMPC and XSalsa20. 对称密钥模式：CBC，CFB，CTS，GOFB，OFB，OpenPGPCFB和SIC（或CTR）。 对称密钥填充： ISO10126d2, ISO7816d4, PKCS-5/7, TBC, X.923, and Zero Byte. 非对称密钥算法： ElGamal, DSA, ECDSA, NaccacheStern and RSA (with blinding). 非对称密钥填充/编码：ISO9796d1, OAEP, and PKCS-1.数字签名电子商务中数据传输的几个安全性需求 1、数据的保密性：用于防止非法用户进入系统及合法用户对系统资源的非法使用；通过对一些敏感的数据文件进行加密来保护系统之间的数据交换，防止除接收方之外的第三方截获数据及即使获取文件也无法得到其内容。如在电子交易中，避免遭到黑客的袭击使信用卡信息丢失的问题。 2、数据的完整性：防止非法用户对进行交换的数据进行无意或恶意的修改、插入，防止交换的数据丢失等。 3、数据的不可否认性：对数据和信息的来源进行验证，以确保数据由合法的用户发出；防止数据发送方在发出数据后又加以否认；同时防止接收方在收到数据后又否认曾收到过此数据及篡改数据。 ==注：== 上述需求对应于防火墙、加密、数字签名、身份认证等技术，但其关键在于数字签名技术。 数字签名的含义 数字签名是通过一个单向函数对要传送的报文进行处理得到的用以认证报文来源并核实报文是否发生变化的一个字母数字串。 数字签名的实现方法实现数字签名有很多方法，目前数字签名采用较多的是公钥加密技术，如基于RSA Date Security 公司的PKCS( Public Key Cryptography Standards )、Digital Signature Algorithm、x.509、PGP(Pretty Good Privacy)。 1994年美国标准与技术协会公布了数字签名标准(DSS)而使公钥加密技术广泛应用。公钥加密系统采用的是非对称加密算法。 由SignerUtilities支持的签名算法MD2withRSA, MD4withRSA,MD5withRSA,RIPEMD128withRSA, RIPEMD160withECDSA, RIPEMD160withRSA,RIPEMD256withRSA, SHA-1withRSA, SHA-224withRSA,SHA-256withRSAandMGF1, SHA-384withRSAandMGF1, SHA-512withRSAandMGF1,SHA-1withDSA, and SHA-1withECDSA 使用范例：（带注释）SHA-1:对于长度小于2^64位的消息，SHA1会产生一个160位(40个字符)的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 SHA-1有如下特性： 不可以从消息摘要中复原信息； 两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。利用SHA-1算法和RSA秘钥进行签名验签代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274import javax.crypto.Cipher;import java.io.*;import java.security.*;import java.util.Base64;/** * @author: mmzsit * @date: 2018年10月24日 * @Description: * 博客地址：https://blog.mmzsblog.cn * @version V1.0 */public class EncryptUtil &#123; public static void main(String[] args) &#123; ObjectInputStream inputStream = null; //参数字符串 String userName=&quot;测试test0-&gt;1&quot;; String orderId=&quot;测试ID123456&quot;; String price=&quot;666&quot;; //构建用于签名和传输的字符串 StringBuffer bufferStr =new StringBuffer(); bufferStr.append(&quot;userName=&quot;).append(userName) .append(&quot;&amp;orderId=&quot;).append(orderId) .append(&quot;&amp;price=&quot;).append(price); //将构建的字符串转化为String类型 String localStr =bufferStr.toString(); //签名算法加密 try &#123; //随机生成秘钥对 // 检查是否存在这对密钥，否则生成这些密钥 if (!areKeysPresent()) &#123; // 使用RSA算法生成一对密钥，并存储在指定路径的指定文件中 generateKey(); &#125; //服务端数字签名开始 //第一步：用SHA-1算出原文的摘要 byte[] shaDigest = shaEncrypt(localStr); System.out.println(&quot;原文本内容：\\n&quot;+localStr); String shaStr = new String(shaDigest,&quot;UTF-8&quot;); System.out.println(&quot;原文本内容SHA-1算法后：\\n&quot;+shaStr); //第二步：使用私钥对原文进行加密 //读取文件中的私钥 inputStream = new ObjectInputStream(new FileInputStream(PRIVATE_KEY_FILE)); final PrivateKey privateKey = (PrivateKey) inputStream.readObject(); //使用私钥加密 byte[] rsaBytes = rsaEncrypt(shaDigest,privateKey); //第三步：对密文进行BASE64编码 byte[] base64Str = Base64.getEncoder().encode(rsaBytes); String base64enCode=new String(base64Str,&quot;UTF-8&quot;); //一般长度是172 System.out.println(&quot;加密后的内容长度：\\n&quot;+base64enCode.length()); System.out.println(&quot;加密后的内容：\\n&quot;+base64enCode); //签名加密完成数据传输到客户端 //客户端验证签名开始 //获取原文 String receiveStr=localStr; //第一步：使用Base64解码密文 byte[] bese64Decoded =Base64.getDecoder().decode(base64enCode.getBytes(&quot;UTF-8&quot;)); //第二步：使用公钥对密文进行解码 //读取文件中的公钥 inputStream = new ObjectInputStream(new FileInputStream(PUBLIC_KEY_FILE)); final PublicKey publicKey = (PublicKey) inputStream.readObject(); //使用公钥解密 byte[] rsaDecode = rsaDecrypt(bese64Decoded,publicKey); //公钥解密后的结果 String base64denCode=new String(rsaDecode,&quot;utf-8&quot;); System.out.println(&quot;公钥解密后的结果：\\n&quot;+base64denCode); //第三步：验签 //读取解密后的摘要 String sha1=Base64.getEncoder().encodeToString(rsaDecode); //使用Sha-1对原文计算摘要 MessageDigest md =MessageDigest.getInstance(&quot;SHA-1&quot;); String sha2=Base64.getEncoder().encodeToString(md.digest(receiveStr.getBytes(&quot;utf-8&quot;))); //用Sha-1对原文计算摘要结果和解密后的明文比对 if(sha1.equals(sha2)) &#123; System.out.println(&quot;验签成功&quot;); &#125; else &#123; System.out.println(&quot;验签失败&quot;); &#125; System.out.println(&quot;字符串sha1：\\n&quot;+sha1); System.out.println(&quot;字符串sha2：\\n&quot;+sha2); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 用于保存加密算法名称的字符串 */ public static final String ALGORITHM = &quot;RSA&quot;; /** * * 用于保存加密填充名称的字符串 * 如果不填写，那么RSA/NONE/NoPadding就是Bouncy Castle 的默认 RSA 实现 * 备用： */ public static final String PADDING = &quot;RSA/ECB/PKCS1Padding&quot;; /** * 用于保存安全提供程序名称的字符串 */// public static final String PROVIDER = &quot;BC&quot;; /** * 用于保存私钥文件名称的字符串 */ public static final String PRIVATE_KEY_FILE = &quot;d:/Temp/private.key&quot;; /** * 用于保存公钥文件名称的字符串 */ public static final String PUBLIC_KEY_FILE = &quot;d:/Temp/public.key&quot;; /** * 假设最高安全性(即4096位RSA密钥或更大)是非常安全 * 使用1024字节生成包含一对私钥和公钥的密钥。 * 将该组密钥存储在Prvate.key和Public.key文件中。 * * @throws NoSuchAlgorithmException * @throws IOException * @throws FileNotFoundException */ public static void generateKey() &#123; try &#123; Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); final KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALGORITHM); //final KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALGORITHM, PROVIDER); //密钥位数 keyGen.initialize(1024); //密钥对 final KeyPair key = keyGen.generateKeyPair(); File privateKeyFile = new File(PRIVATE_KEY_FILE); File publicKeyFile = new File(PUBLIC_KEY_FILE); // 创建文件夹存储私钥 if (privateKeyFile.getParentFile() != null) &#123; privateKeyFile.getParentFile().mkdirs(); &#125; privateKeyFile.createNewFile(); // 创建文件夹存储公钥 if (publicKeyFile.getParentFile() != null) &#123; publicKeyFile.getParentFile().mkdirs(); &#125; publicKeyFile.createNewFile(); // 创建文件夹保存公钥 ObjectOutputStream publicKeyOS = new ObjectOutputStream( new FileOutputStream(publicKeyFile)); publicKeyOS.writeObject(key.getPublic()); publicKeyOS.close(); // 创建文件夹保存私钥 ObjectOutputStream privateKeyOS = new ObjectOutputStream( new FileOutputStream(privateKeyFile)); privateKeyOS.writeObject(key.getPrivate()); privateKeyOS.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 检查是否已生成一对公钥和私钥 * * @return boolean 返回是否生成秘钥对的标识 */ public static boolean areKeysPresent() &#123; File privateKey = new File(PRIVATE_KEY_FILE); File publicKey = new File(PUBLIC_KEY_FILE); if (privateKey.exists() &amp;&amp; publicKey.exists()) &#123; return true; &#125; return false; &#125; /** * 使用公钥解密数据 * * @param text 待解密文本 * @param key 公钥 * @return 解密文本 * @throws java.lang.Exception */ public static byte[] rsaDecrypt(byte[] text, PublicKey key) &#123; byte[] cipherText = null; try &#123; // 获取RSA密码对象并打印提供程序// Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); final Cipher cipher = Cipher.getInstance(PADDING); //final Cipher cipher = Cipher.getInstance(PADDING, PROVIDER); // 使用公钥，ENCRYPT_MODE表示为解密模式 cipher.init(Cipher.DECRYPT_MODE, key); cipherText = cipher.doFinal(text); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return cipherText; &#125; /** * 使用私钥加密数据 * * @param text 待加密文本 * @param key 私钥 * @return 加密后的数据 * @throws java.lang.Exception */ public static byte[] rsaEncrypt(byte[] text, PrivateKey key) &#123; byte[] dectyptedText = null; try &#123;// //获取RSA密码对象并打印提供程序// Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); final Cipher cipher = Cipher.getInstance(PADDING); //final Cipher cipher = Cipher.getInstance(PADDING, PROVIDER); // 使用私钥加密文本 cipher.init(Cipher.ENCRYPT_MODE, key); dectyptedText = cipher.doFinal(text); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return dectyptedText; &#125; /** * 使用sha-1对摘要进行加密 * @param text 签名的原始文本 */ public static byte[] shaEncrypt(String text) &#123; //创建消息摘要算法的类 MessageDigest md = null; //由于接收加密后的摘要的字节数组 byte[] shaDigest = null; try &#123; //使用getInstance(&quot;算法&quot;)来获得消息摘要 md = MessageDigest.getInstance(&quot;SHA-1&quot;); //将摘要转化为UTF-8格式的字节数组 byte[] plainText = text.getBytes(&quot;UTF-8&quot;); //使用指定的 byte 数组更新摘要 md.update(plainText); //得出SHA-1算法加密后的结果 shaDigest=md.digest(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return shaDigest; &#125; &#125; 参考文章： https://my.oschina.net/u/242764/blog/481503 https://blog.csdn.net/WuLex/article/details/72862140 https://juejin.im/post/5aa22ee9518825558358d30c","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"加密算法","slug":"加密算法","permalink":"https://blog.mmzsblog.cn/tags/加密算法/"}]},{"title":"日志框架","slug":"日志框架","date":"2018-10-24T02:24:00.000Z","updated":"2019-02-13T06:40:51.494Z","comments":true,"path":"J2ee/日志框架/","link":"","permalink":"https://blog.mmzsblog.cn/J2ee/日志框架/","excerpt":"","text":"日志框架的概念日志的作用是用来追踪和记录我们的程序运行中的信息，我们可以利用日志很快定位问题，追踪分析。 日志级别首先要知道日志级别是干什么用的，日志级别是当你使用不同的方式运行的时候，根据你运行的方式和你设置的日志打印级别来确定哪些信息需要输出。 规定：日志只会打印设置的优先级及比自己高优先级的内容。日志级别优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL OFF： FATAL： ERROR： WARN： INFO： DEBUG： TRACE： ALL：常用的日志框架Jul: Java Util LoggingSun公司的日志框架，原生的日志框架，优点是使用非常简单，直接在 JDK 中就可以使用。但 JDKLog 功能比较太过于简单，不支持占位符显示，拓展性比较差，所以现在用的人也很少。示例：12345678910111213import java.util.logging.Logger; /**** ** JDKLog Demo **/public class JDKLog&#123; public static void main( String[] args ) &#123; Logger logger = Logger.getLogger(&quot;JDKLog&quot;); logger.info(&quot;Hello World.&quot;); &#125;&#125; Log4jApache的日志框架，有多个分级（DEBUG/INFO/WARN/ERROR）记录级别，可以很好地将不同日志级别的日志分开记录，极大地方便了日志的查看。 引入依赖包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 123456789101112131415161718192021222324 ### 设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n Log4J2Log4j升级版，2.x的版本在架构上进行了一些升级，配置文件也发生了一些变化。 引入依赖包1234567891011&lt;!-- Log4J --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt; 注：log4j和log4j2的依赖包路径是不一样的，这是为了区分log4j和log4j2，开发者专门设置的。 增加配置文件 log4j2.xml 放在 resource 目录下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;error&quot;&gt; &lt;!-- 先定义所有的appender --&gt; &lt;appenders&gt; &lt;!-- 这个输出控制台的配置 --&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!-- 控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt; &lt;ThresholdFilter level=&quot;trace&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!-- 这个都知道是输出日志的格式 --&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/Console&gt; &lt;!-- 文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用 --&gt; &lt;!-- append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true --&gt; &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别 onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;意思是匹配就接受,否则直接拒绝 --&gt; &lt;File name=&quot;ERROR&quot; fileName=&quot;logs/error.log&quot;&gt; &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy.MM.dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/web.log&quot; filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;2MB&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!-- 然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt; &lt;loggers&gt; &lt;!-- 建立一个默认的root的logger --&gt; &lt;root level=&quot;trace&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Commons Logging日志门面，支持运行时动态加载日志组件实现。也就是说，在应用代码中，只需要调用commons logging的接口，底层实现可以是log4j，也可以是Java Util Logging。 Slf4J与Commons Logging对立的阵营，这是接口，实现是Logback。 LogbackSlf4J的实现。 Commons Logging与Slf4j实现机制对比 Commons logging实现机制：Commons logging是通过动态查找机制，在程序运行时，使用自己的ClassLoader寻找和载入本地具体的实现。详细策略可以查看commons-logging-*.jar包中的org.apache.commons.logging.impl.LogFactoryImpl.java文件。由于OSGi不同的插件使用独立的ClassLoader，OSGI的这种机制保证了插件互相独立, 其机制限制了commons logging在OSGi中的正常使用。 Slf4j实现机制：Slf4j在编译期间，静态绑定本地的LOG库，因此可以在OSGi中正常使用。它是通过查找类路径下org.slf4j.impl.StaticLoggerBinder，然后绑定工作都在这类里面进。如果在项目中如果选择日志框架 Slf4j实现机制决定Slf4j限制较少，使用范围更广。由于Slf4j在编译期间，静态绑定本地的LOG库使得通用性要比Commons logging要好。 Logback拥有更好的性能。Logback声称：某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在Logback中需要3纳秒，而在Log4J中则需要30纳秒。LogBack创建记录器（logger）的速度也更快：13毫秒，而在Log4J中需要23毫秒。更重要的是，它获取已存在的记录器只需94纳秒，而Log4J需要2234纳秒，时间减少到了1/23。跟JUL相比的性能提高也是显著的。 Commons Logging开销更高 在使Commons Logging时为了减少构建日志信息的开销，通常的做法是： 1234if(log.isDebugEnabled())&#123; log.debug(&quot;User name： &quot; + user.getName() + &quot; buy goods id ：&quot; + good.getId());&#125; 在Slf4j阵营，你只需这么做：1log.debug(&quot;User name：&#123;&#125; ,buy goods id ：&#123;&#125;&quot;, user.getName(),good.getId()); 也就是说，slf4j把构建日志的开销放在了它确认需要显示这条日志之后，减少内存和cup的开销，使用占位符号，代码也更为简洁。 Logback文档免费。Logback的所有文档是全面免费提供的，不象Log4J那样只提供部分免费文档而需要用户去购买付费文档。如何在项目中使用Slf4JSlf4J与其他各种日志的桥接jar包名 | 说明—|—slf4j-log4j12-1.7.13.jar | log4j1.2版本的桥接器，你需要将log4j.jar加入classpath。slf4j-jdk14-1.7.13.jar | java.util.logging的桥接器，JDK原生日志框架。slf4j-nop-1.7.13.jar|NOP桥接器，默默丢弃一切日志。slf4j-simple-1.7.13.jar| 一个简单实现的桥接器，该实现输出所有事件到System.err. 只有INFO以及高于该级别的消息被打印，在小型应用中它也许是有用的。slf4j-jcl-1.7.13.jar| Jakarta Commons Logging 的桥接器. 这个桥接器将SLF4j所有日志委派给JCL。logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)|slf4j的原生实现，logback直接实现了slf4j的接口，因此使用slf4j与 logback的结合使用也意味更小的内存与计算开销具体接入方式如下：如何桥接遗留的API在使用不同的框架的时候，可能别人集成的框架不一样。比如Spring Framework集成的是Commons Logging，而XSocket依赖的是Java Util Logging。现在我们需要解决不同框架中的不同日志组件都统一为Slf4J。SLF4J会根据绑定器把日志交给具体的日志实现工具。Slf4J带有几个桥接模块，可以重定向log4j，JCL和Java.util.logging中的api到Slf4J。遗留的api桥接方案jar包名|作用—|—log4j-over-slf4j-version.jar|将log4j重定向到slf4jjcl-over-slf4j-version.jar|将commons logging里的Simple Logger重定向到slf4jjul-to-slf4j-version.jar|将Java Util Logging 重定向到slf4j桥接方式参考下图：使用slf4j桥接要注意事项在使用slf4j桥接时要注意避免形成死循环，在项目依赖的jar包中不要存在以下情况: 多个日志jar包形成死循环的条件 产生原因 log4j-over-slf4j.jar和slf4j-log4j12.jar同时存在 由于slf4j-log4j12.jar的存在会将所有日志调用委托给log4j。但由于同时由于log4j-over-slf4j.jar的存在，会将所有对log4j api的调用委托给相应等值的slf4j,所以log4j-over-slf4j.jar和slf4j-log4j12.jar同时存在会形成死循环 jul-to-slf4j.jar和slf4j-jdk14.jar同时存在 由于slf4j-jdk14.jar的存在会将所有日志调用委托给jdk的log。但由于同时jul-to-slf4j.jar的存在，会将所有对jul api的调用委托给相应等值的slf4j，所以jul-to-slf4j.jar和slf4j-jdk14.jar同时存在会形成死循环。","categories":[{"name":"J2ee","slug":"J2ee","permalink":"https://blog.mmzsblog.cn/categories/J2ee/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://blog.mmzsblog.cn/tags/框架/"}]},{"title":"注解@CrossOrigin详解","slug":"注解@CrossOrigin详解","date":"2017-08-08T02:24:00.000Z","updated":"2019-02-13T06:40:51.514Z","comments":true,"path":"Java/注解@CrossOrigin详解/","link":"","permalink":"https://blog.mmzsblog.cn/Java/注解@CrossOrigin详解/","excerpt":"","text":"注解@CrossOrigin 出于安全原因，浏览器禁止Ajax调用驻留在当前原点之外的资源。例如，当你在一个标签中检查你的银行账户时，你可以在另一个选项卡上拥有EVILL网站。来自EVILL的脚本不能够对你的银行API做出Ajax请求（从你的帐户中取出钱！）使用您的凭据。 跨源资源共享（CORS）是由大多数浏览器实现的W3C规范，允许您灵活地指定什么样的跨域请求被授权，而不是使用一些不太安全和不太强大的策略，如IFRAME或JSONP。 跨域(CORS)支持： Spring Framework 4.2 GA为CORS提供了第一类支持，使您比通常的基于过滤器的解决方案更容易和更强大地配置它。所以springMVC的版本要在4.2或以上版本才支持@CrossOrigin 使用方法：controller配置CORScontroller方法的CORS配置你可以向@RequestMapping注解处理程序方法添加一个@CrossOrigin注解，以便启用CORS（默认情况下，@CrossOrigin允许在@RequestMapping注解中指定的所有源和HTTP方法）：123456789101112131415@RestController@RequestMapping(\"/account\")public class AccountController &#123; @CrossOrigin @GetMapping(\"/&#123;id&#125;\") public Account retrieve(@PathVariable Long id) &#123; // ... &#125; @DeleteMapping(\"/&#123;id&#125;\") public void remove(@PathVariable Long id) &#123; // ... &#125;&#125; 其中@CrossOrigin中的2个参数： origins： 允许可访问的域列表 maxAge:准备响应前的缓存持续的最大时间（以秒为单位）。 为整个controller启用@CrossOrigin123456789101112131415@CrossOrigin(origins = \"http://domain2.com\", maxAge = 3600)@RestController@RequestMapping(\"/account\")public class AccountController &#123; @GetMapping(\"/&#123;id&#125;\") public Account retrieve(@PathVariable Long id) &#123; // ... &#125; @DeleteMapping(\"/&#123;id&#125;\") public void remove(@PathVariable Long id) &#123; // ... &#125;&#125; 在这个例子中，对于retrieve()和remove()处理方法都启用了跨域支持，还可以看到如何使用@CrossOrigin属性定制CORS配置。 同时使用controller和方法级别的CORS配置Spring将合并两个注释属性以创建合并的CORS配置。12345678910111213141516@CrossOrigin(maxAge = 3600)@RestController@RequestMapping(\"/account\")public class AccountController &#123; @CrossOrigin(origins = \"http://domain2.com\") @GetMapping(\"/&#123;id&#125;\") public Account retrieve(@PathVariable Long id) &#123; // ... &#125; @DeleteMapping(\"/&#123;id&#125;\") public void remove(@PathVariable Long id) &#123; // ... &#125;&#125; 如果正在使用Spring Security请确保在Spring安全级别启用CORS，并允许它利用Spring MVC级别定义的配置。12345678@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and()... &#125;&#125; 全局CORS配置 除了细粒度、基于注释的配置之外，您还可能需要定义一些全局CORS配置。这类似于使用筛选器，但可以声明为Spring MVC并结合细粒度@CrossOrigin配置。默认情况下，所有origins and GET, HEAD and POST methods是允许的。 JavaConfig使整个应用程序的CORS简化为： 123456789@Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\"); &#125;&#125; 如果你正在使用Spring Boot，建议将WebMvcConfigurer bean声明如下： 12345678910111213@Configurationpublic class MyConfiguration &#123; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\"); &#125; &#125;; &#125;&#125; 你可以轻松地更改任何属性，以及仅将此CORS配置应用到特定的路径模式： 123456789@Overridepublic void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/api/**\") .allowedOrigins(\"http://domain2.com\") .allowedMethods(\"PUT\", \"DELETE\") .allowedHeaders(\"header1\", \"header2\", \"header3\") .exposedHeaders(\"header1\", \"header2\") .allowCredentials(false).maxAge(3600);&#125; 如果你正在使用Spring Security，请确保在Spring安全级别启用CORS，并允许它利用Spring MVC级别定义的配置。 XML命名空间还可以将CORS与MVC XML命名空间配置。 如果整个项目所有方法都可以访问，则可以这样配置此最小XML配置使CORS在/**路径模式具有与JavaConfig相同的缺省属性：123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt;&lt;/mvc:cors&gt; 其中* 表示匹配到下一层；** 表示后面不管有多少层，都能匹配。 如：123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/*&quot;/&gt; &lt;/mvc:cors&gt; 这个可以匹配到的路径有： /api/aaa /api/bbbb 不能匹配的： /api/aaa/bbb 因为* 只能匹配到下一层路径，如果想后面不管多少层都可以匹配，配置如下：123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/**&quot;/&gt; &lt;/mvc:cors&gt; 注：其实就是一个(*)变成两个(**) 也可以用定制属性声明几个CORS映射：12345678910111213&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/**&quot; allowed-origins=&quot;http://domain1.com, http://domain2.com&quot; allowed-methods=&quot;GET, PUT&quot; allowed-headers=&quot;header1, header2, header3&quot; exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;false&quot; max-age=&quot;123&quot; /&gt; &lt;mvc:mapping path=&quot;/resources/**&quot; allowed-origins=&quot;http://domain1.com&quot; /&gt;&lt;/mvc:cors&gt; 请求路径有/api/，方法示例如下：123456@RequestMapping(\"/api/crossDomain\") @ResponseBody public String crossDomain(HttpServletRequest req, HttpServletResponse res, String name)&#123; …… …… &#125; 如果使用Spring Security，不要忘记在Spring安全级别启用CORS：12345&lt;http&gt; &lt;!-- Default to Spring MVC&apos;s CORS configuration --&gt; &lt;cors /&gt; ...&lt;/http&gt; How does it work? CORS请求（包括预选的带有选项方法）被自动发送到注册的各种HandlerMapping。它们处理CORS准备请求并拦截CORS简单和实际请求，这得益于CorsProcessor实现（默认情况下默认DefaultCorsProcessor处理器），以便添加相关的CORS响应头（如Access-Control-Allow-Origin）。CorsConfiguration允许您指定CORS请求应该如何处理：允许origins, headers, methods等。 AbstractHandlerMapping#setCorsConfiguration()允许指定一个映射，其中有几个CorsConfiguration映射在路径模式上，比如/api/**。 子类可以通过重写AbstractHandlerMapping类的getCorsConfiguration(Object, HttpServletRequest)方法来提供自己的CorsConfiguration。 处理程序可以实现CorsConfigurationSource接口（如ResourceHttpRequestHandler），以便为每个请求提供一个CorsConfiguration。 基于过滤器的CORS支持 作为上述其他方法的替代，Spring框架还提供了CorsFilter。在这种情况下，不用使用@CrossOrigin或WebMvcConfigurer#addCorsMappings(CorsRegistry),，例如，可以在Spring Boot应用程序中声明如下的过滤器：1234567891011121314151617@Configurationpublic class MyConfiguration &#123; @Bean public FilterRegistrationBean corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin(\"http://domain1.com\"); config.addAllowedHeader(\"*\"); config.addAllowedMethod(\"*\"); source.registerCorsConfiguration(\"/**\", config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean; &#125;&#125; spring注解@CrossOrigin不起作用的原因 1、是springMVC的版本要在4.2或以上版本才支持@CrossOrigin 2、非@CrossOrigin没有解决跨域请求问题，而是不正确的请求导致无法得到预期的响应，导致浏览器端提示跨域问题。 3、在Controller注解上方添加@CrossOrigin注解后，仍然出现跨域问题，解决方案之一就是：在@RequestMapping注解中没有指定Get、Post方式，具体指定后，问题解决。类似代码如下： 123456789@CrossOrigin@RestControllerpublic class person&#123; @RequestMapping(method = RequestMethod.GET) public String add() &#123; // 若干代码 &#125;&#125; 参考文章： 1、官方文档：https://spring.io/blog/2015/06/08/cors-support-in-spring-framework 2、http://fanshuyao.iteye.com/blog/2384189 3、https://blog.csdn.net/taiyangnimeide/article/details/78305131 4、https://blog.csdn.net/snowin1994/article/details/53035433","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://blog.mmzsblog.cn/tags/注解/"}]},{"title":"初级程序员需要知道的基本代码规范","slug":"初级程序员需要知道的基本代码规范","date":"2016-12-05T13:26:14.000Z","updated":"2019-02-13T06:40:51.484Z","comments":true,"path":"Java/初级程序员需要知道的基本代码规范/","link":"","permalink":"https://blog.mmzsblog.cn/Java/初级程序员需要知道的基本代码规范/","excerpt":"","text":"初级程序员需要知道的基本代码规范作为一个程序员，写代码乱糟糟的咋行呢？所以今天我将我在《阿里巴巴Java开发手册》中看到的一些有用的、适合初级程序员的代码基本规范，分享给大家！ 1.【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则： 1） 左大括号前不换行。 2） 左大括号后换行。 3） 右大括号前换行。 4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。 2.【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。 反例：if (空格 a == b 空格) 3.【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。 4.【强制】任何二目、三目运算符的左右两边都需要加一个空格。 说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。 5.【强制】采用 4 个空格缩进，禁止使用 tab 字符。 说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。正例： （涉及上面五点） 1234567891011121314151617181920public static void main(String[] args) &#123; // 缩进 4 个空格 String say = &quot;hello&quot;; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println(&quot;world&quot;); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(&quot;ok&quot;); // 在右大括号后直接结束，则必须换行 &#125; &#125; 6.【强制】注释的双斜线与注释内容之间有且仅有一个空格。 正例：// 注释内容，注意在//和注释内容之间有一个空格。 7.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则： 1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。 2） 运算符与下文一起换行。 3） 方法调用的点符号与下文一起换行。 4） 方法调用时，多个参数，需要换行时，在逗号后进行。 5） 在括号前不要换行，见反例。 正例： 123456StringBuffer sb = new StringBuffer(); // 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append(&quot;zi&quot;).append(&quot;xin&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;); 反例： 12345678StringBuffer sb = new StringBuffer(); // 超过 120 个字符的情况下，不要在括号前换行sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append (&quot;huang&quot;); // 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行method(args1, args2, args3, ... , argsX); 8.【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。正例：下例中实参的”a”,后边必须要有一个空格。method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); 9.【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。 10.【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 正例： 1234int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer(); 说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。 11.【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。 说明：没有必要插入多个空行进行隔开。 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 【强制】不能使用过时的类或方法。 说明：java.net.URLDecoder中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 正例：&quot;test&quot;.equals(object); 反例：object.equals(&quot;test&quot;); 说明：推荐使用 java.util.Objects#equals（JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行 判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。 说明： 1234String str = &quot;a,b,c,,&quot;; String[] ary = str.split(&quot;,&quot;); // 预期大于 3，结果是 3System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第 15 条规则。 15.【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。 16.【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。反例： 1234567public Integer getData() &#123; if (true) &#123; return this.data + 100; &#125; else &#123; return this.data - 100; &#125; &#125; 17.【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。 说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 反例： 1234String str = &quot;start&quot;; for (int i = 0; i &lt; 100; i++) &#123; str = str + &quot;hello&quot;; &#125; 18.【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字： 1） 不允许被继承的类，如：String 类。 2） 不允许修改引用的域对象，如：POJO 类的域变量。 3） 不允许被重写的方法，如：POJO 类的 setter 方法。 4） 不允许运行过程中重新赋值的局部变量。 5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。 【强制】中括号是数组类型的一部分，数组定义如下：String[] args; 【强制】POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误； 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？正例：// 伪代码如下： 1234final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) &#123; ... &#125; 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements; 【推荐】类内方法定义顺序依次是：公有方法或保护方法&gt;私有方法&gt;getter/setter方法；&nbsp;&nbsp;&nbsp;&nbsp;说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。如需了解更多，请看《阿里巴巴Java开发手册》 ;","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://blog.mmzsblog.cn/tags/编程语言/"}]},{"title":"Java内存模型","slug":"Java内存模型","date":"2016-10-31T02:24:00.000Z","updated":"2019-02-13T06:40:51.456Z","comments":true,"path":"Java/Java内存模型/","link":"","permalink":"https://blog.mmzsblog.cn/Java/Java内存模型/","excerpt":"","text":"内存模型概念内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程的抽象。 Java内存模型Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 主内存和与工作内存主内存Java内存模型规定了所有的变量都保存在主内存中。 工作内存每个线程有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。 主内存和工作内存的关系 线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接读写主内存中的变量。 不同的线程之间无法直接访问对方工作内存中的变量。 线程间变量值的传递均需要通过主内存来完成。内存间交互操作Java定义了以下8中操作来完成变量与主内存中间的操作，如变量如何从主内存中拷贝到工作内存、如何从工作内存同步回主内存等。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（double和long类型的变量允许有例外）。 lock：锁定，作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock：解锁，作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read：读取，作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load：载入，作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use：使用，作用于工作内存中的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign：赋值，作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，没到虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store：存储，作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write：写入，作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 注：如果想要把变量从主内存中复制到工作内存中，那么就要按顺序执行read和load操作；如果是要把工作内存中的变量同步到主内存中，那么就要顺序执行store和write操作。但是Java虚拟机只规定这两个操作是必须按顺序执行，其他的可以不用。而且，这两组操作，不需要连续执行，比如可以这样：1read a ,read b,load b,load a Java虚拟机还规定了以下8种基本操作时的规则： 不允许read和load、store和write单独单一出现。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起会写但是猪内存不接受的情况出现。 不允许一个线程丢弃它最近的assign的操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个呗其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。volatilevolatile可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量呗声名为volatile类型后，它将具备两个特性： 保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的。但是，Java的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。 即valatile只能保证可见性，所以通常我们还是需要使用synchronized或java.util.concurrent中的原子来来保证原子性。 除了以下两种情况： 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 例：123456789volatile boolean shutdownRequested;public void shutdown()&#123; shutdownRequested = true;&#125;public void doWork()&#123; while(!shutdownRequested)&#123; //do something &#125;&#125; 分析结果： 上面的例子可以保证当shutdown被调用时，能保证所有线程中执行doWork()方法立即停止。 禁止指令重排序优化，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。而volatile关键字能够避免此类情况的发生。 例，如下伪代码：123456789101112131415161718Map configOptions;char[] configText;//此变量必须定义为volatile，否则无法保证多线程情况下的有序性。volatile boolean initialized = false;//假设以下代码在线程A中执行//目标：当配置完成后，其他线程才能使用。也就是说当initialized为true时，其他线程才能使用。configOptions = new hashMap();configText = readConfigFile(fileName);processConfigOptions(configText,configOptions);initialized = true;//假设以下代码在线程B中执行//如果initialized为false，则一直休眠等待，直到initialized为truewhile(!initialized)&#123; sleep();&#125;//当initialized为true后执行doSomething(); 代码分析： 如果initialized没有被volatile修饰，就可能由于指令重排序的优化，导致位于线程A中的最后一句代码initialized=true提前执行。 总结：volatile变量读操作的性能消耗与普通变量并太大差别，但是写操作可能会慢一些，因为它需要再本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 对于long和double型变量的特殊规则允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，也就是说多线程在调用没有被volatile修饰的long或者double型变量的时候可能调到半个变量的数值。但是这种情况非常罕见，因为Java虚拟机可以选择把这两个操作实现为具有原子性操作，而且基本上虚拟机也就这么做了。 原子性、可见性和有序性 原子性：由Java内存模型来直接保证的原子性操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的。 可见性：指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取钱从主内存刷新变量值这种依赖主内存作传递媒介的方式来实现可见性的。 普通变量和volatile修饰的变量是一样的，只是volatile保证了新值能够立即同步到主内存，每次使用前立即从主内存刷新。 synchronized关键字保证可见性：对一个变量执行unlock之前，必须先把此变量同步回主内存中。 final关键字保证可见性：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那在其他线程中就能看见final字段的值。 有序性：总结一下，如果在本线程中，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。 先行发生原则 程序次序规则：在一个线程内，按照程序代码顺序（控制流顺序及逻辑顺序），前面的代码比后面的代码先行发生。 管程锁定规则：一个unlock操作先行发生于后面对于同一个锁的lock操作。 volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。 对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就说明操作A先行发生于操作C。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"虚拟机字节码执行引擎","slug":"虚拟机字节码执行引擎","date":"2016-10-30T02:24:00.000Z","updated":"2019-02-13T06:40:51.533Z","comments":true,"path":"Java/虚拟机字节码执行引擎/","link":"","permalink":"https://blog.mmzsblog.cn/Java/虚拟机字节码执行引擎/","excerpt":"","text":"执行引擎概述执行引擎是虚拟机最核心的组成部分之一。可能分为： 解释执行：通过解释器执行 编译执行：通过即时编译器产生本地代码执行。运行时栈帧结构栈帧用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。注意：每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。栈帧存储的东西包括：方法的局部变量表 是一组变量值存储空间，用于存放参数和方法内部定义的局部变量。 在编译为Class文件时，就在方法的Code属性的max_locals确定了局部变量表的最大容量。 在方法执行时，虚拟机使用局部变量表来完成参数值到参数变量列表的传递过程。 如果是非静态方法，局部变量表中第0个索引的slot默认是用于传递方法所属的对象实例的引用，即this关键字。其余参数按照参数表顺序排列。 为了节省空间，slot可重用。slot(Variable Slot，变量槽) 局部变量表容量的最小单位。 每个slot都应该可以存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据。 一个slot可以存放32位以内的数据类型。 reference表示对对象数据的引用： 可以通过此引用直接或间接地查找到对象在Java堆中的数据存放的起始地址索引。 可以通过此引用直接或间接地查找到对象所属数据类型在方法区中的存储类型信息。 64位的数据类型，虚拟机会以最高位对齐的方式为其分配两个连续的slot空间。 64位的只有long和double两种。虚拟机通过索引定位的方式使用局部变量表。索引范围从0开始，到最大的slot数量。注：局部变量必须赋初值，与类变量不一样。操作数栈 也就是操作栈，后进先出（LIFO）栈。 也是在编译时就已经确定栈的最大深度，在方法的Code属性的max_stacks确定。 操作数栈的每一个元素可以是任意的数据类型，包括long和double。 32位所占的栈容量为1,64位所占的栈容量为2。 在方法执行的任何时候，操作数栈的深度都不会超过max_stacks。动态链接方法返回地址在方法退出之后，都需要返回到方法被调用的位置程序才能继续执行。方法退出的过程，实际上就等于把当前栈出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向调用指令后面的一条指令。方法的退出方式： 正常完成出口：调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器的值。 异常完成出口：返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。额外的附加信息方法调用 方法调用不同于方法执行。解析分派静态分派(Method Overload Resolution，方法重载分派)1234567891011121314151617181920212223/** * 方法静态分派演示 */public class MethodOverloadResolution &#123; static abstract class Human&#123;&#125; static class Man extends Human&#123;&#125; static class Woman extends Human&#123;&#125; public void sayHello(Human human)&#123; System.out.println(&quot;hello human!&quot;); &#125;public void sayHello(Man man)&#123; System.out.println(&quot;hello man!&quot;); &#125;public void sayHello(Woman woman)&#123; System.out.println(&quot;hello woman!&quot;); &#125; public static void main(String[] args) &#123; MethodOverloadResolution m = new MethodOverloadResolution(); Human man = new Man(); Human woman = new Woman(); m.sayHello(man); m.sayHello(woman); &#125;&#125; 运行结果：1234hello human!hello human!Process finished with exit code 0 分析：首先解释两个概念：Human称为man这个对象的静态类型(Static Type)，而Man称为man这个对象的实际类型(Actual Type)。 静态类型的变化仅仅在使用时发生，变量本身的静态类型不会改变，静态类型在编译期可知 实际类型变化是在运行期才确定，编译器在编译的时候并不知道一个对象的实际类型是什么。 例： 123456//实际类型变化Human man = new Man();Human woman = new Woman();//静态类型变化m.sayHello((Man)man);m.sayHello((Woman)woman); 继续解读以上代码：在main()方法的两次sayHello()方法，已经确定了对象m是方法的接收者。在这个前提下，要使用哪个方法进行重载，完全取决于参数的参数列表（包括参数类型、参数个数等）。代码中刻意地定义了两个静态类型相同而实际类型不同的变量，但是编译器在重载的时候是通过参数的静态类型而不是实际类型进行判断的。并且静态类型是编译期可知。 注：方法重载是静态分派的典型应用。 动态分派123456789101112131415161718192021222324252627282930package com.laowang.vm.invoke;/** * 方法动态分派演示 */public class MethodOverrideResolution &#123; static abstract class Human&#123; protected abstract void sayHell(); &#125; static class Man extends Human&#123; @Override protected void sayHell() &#123; System.out.println(&quot;man say hello&quot;); &#125; &#125;static class Woman extends Human&#123; @Override protected void sayHell() &#123; System.out.println(&quot;woman say hello&quot;); &#125; &#125; public static void main(String[] args) &#123; Human man = new Man(); Human woman = new Woman(); man.sayHell(); woman.sayHell(); man = new Woman(); man.sayHell(); &#125;&#125; 运行结果：12345man say hellowoman say hellowoman say helloProcess finished with exit code 0 注：方法重写是动态分派的典型应用。 单分派与多分派12345678910111213141516171819202122232425262728293031323334/** * 单分派和多分派演示 */public class Dispatcher &#123; static class QQ&#123; &#125; static class _360&#123; &#125; public static class Father&#123; public void hardChoice(QQ arg)&#123; System.out.println(&quot;father choose qq!&quot;); &#125; public void hardChoice(_360 arg)&#123; System.out.println(&quot;father choose 360!&quot;); &#125; &#125; public static class Son extends Father&#123; @Override public void hardChoice(QQ arg)&#123; System.out.println(&quot;son choose qq!&quot;); &#125; @Override public void hardChoice(_360 arg)&#123; System.out.println(&quot;son choose 360!&quot;); &#125; public static void main(String[] args) &#123; Father father = new Father(); Father son = new Son(); father.hardChoice(new _360()); son.hardChoice(new QQ()); &#125; &#125;&#125; 运行结果：12father choose 360!son choose qq! 动态语言支持动态类型语言动态类型语言的关键特征是它的类检查的主体过程是在运行期而不是编译期。 注：变量无类型而变量值才有类型是动态类型语言的一个重要特征。 JDK1.7与动态类型java.lang.invoke包在以前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为MethodHandle。例：12345678910111213141516171819202122232425262728293031323334353637package com.laowang.vm;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup;/** * Method handle 基础用法演示 */public class TestMethodHandle &#123; static class ClassA &#123; public void println(String s) &#123; System.out.println(s); &#125; &#125; public static void main(String[] args) throws Throwable &#123; Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA(); getPrintlnMH(obj).invoke(&quot;icyfenix&quot;); &#125; /** * MethodType:代表“方法类型”，包含了方法的返回值和具体参数（第一个参数和第二个及以后的参数） * lookup()方法来自于MethodHandle.lookup，这句的作用是在指定类中查找符合给定的方法名称，方法类型，并且符合调用权限的方法句柄。 * * 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也就是this指向的对象， * 这个参数以前是放在列表中进行传递的，而现在提供了bindTo()方法来完成这件事情。 * @param receiver * @return * @throws Throwable */ private static MethodHandle getPrintlnMH(Object receiver) throws Throwable&#123; MethodType mt = MethodType.methodType(void.class,String.class); return lookup().findVirtual(receiver.getClass(),&quot;println&quot;,mt).bindTo(receiver); &#125;&#125; 但是，不是可以用反射(Reflection)来解决这样的问题吗？ MethodHandle与反射的区别 反射是在Java代码级别的模拟方法调用，而MethodHandle是在字节码级别。 MethodHandle的findStatic(),findVirtual(),findSpecial()对应于invokestatic,invokevirtual&amp;invokeinterface和invokespecial这几条字节码指令执行的权限校验行为，但是在Reflection API中无需关心。 Reflection中的java.lang.reflect.Hethod对象所包含的信息比java.lang.invoke.MethodHandle对象所包含的信息多。 **最关键的一点，Reflection API只是为了Java语言服务，而MethodHandle可以设计成服务于所有Java虚拟机，当然也包括Java语言。**invokedynamic指令每一处含有invokedynamic指令的位置都称作”动态调用点（Dynamic Call Site）“，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_MethodrefDynamic_info常量，从这个常量中可以得到三个信息： Bootsrap method：引导方法，有固定的参数，返回值为java.lang.invoke.CallSite，这个代表真正的要执行的目标方法调用。 Method Type：方法类型 名称掌握方法分派规则*","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"虚拟机类加载机制","slug":"虚拟机类加载机制","date":"2016-10-29T02:24:00.000Z","updated":"2019-02-13T06:40:51.538Z","comments":true,"path":"Java/虚拟机类加载机制/","link":"","permalink":"https://blog.mmzsblog.cn/Java/虚拟机类加载机制/","excerpt":"","text":"虚拟机类加载机制概念虚拟机把描述类的数据从Class文件中读取到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机类加载机制。这个过程在程序运行期间完成。 类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括： 加载（Loading） 验证（Verification） 准备（Prepareation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading）==其中：验证、准备解析3个部分统称为连接（Linking）==为了支持Java语言的运行时绑定（动态绑定），解析阶段不一定按部就班执行，在一些情况下它可以再初始化阶段之后开始。有且仅有以下5种情况，必须立即对类进行初始化： 在遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先出发其初始化（即加载、验证、准备也需要在这之前开始）。最常见的Java代码场景是：new对象、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先出发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先出发其父类的初始化。 当虚拟机启动时，用户需要制定一个要执行的主类（包含main()方法的类），虚拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先触发其初始化。被动引用的例子例1：使用子类直接调用父类的静态属性，因为该静态属性是在父类中定义的，所以不会在子类初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。123456789101112131415161718192021package com.laowang.vm.classloader;public class SuperClass &#123; static&#123; System.out.println(&quot;I&apos;m super class!&quot;); &#125; public static int value = 123;&#125;class SubClass extends SuperClass&#123; static&#123; System.out.println(&quot;I&apos;m sub class!&quot;); &#125;&#125;package com.laowang.vm.classloader;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 运行结果： 12345&quot;D:\\Program Files (x86)\\Java\\jdk1.8.0_171\\bin\\java.exe&quot; ...I&apos;m super class!123Process finished with exit code 0 例2：复用以上的SuperClass，使用数组定义来引用类，也不会触发此类的初始化。但，它会触发另外一个名为”[Lcom.laowang.vm.classloader.SuperClass”的类的初始化阶段，这个类是由虚拟机自动生成、直接继承于java.lang.Object的子类，创建动作由字节码newarray触发。12345678package com.laowang.vm.classloader;public class NotInitialization &#123; public static void main(String[] args) &#123; //System.out.println(SubClass.value); SuperClass[] sca = new SuperClass[10]; &#125;&#125; 运行结果：123&quot;D:\\Program Files (x86)\\Java\\jdk1.8.0_171\\bin\\java.exe&quot; ...Process finished with exit code 0 例3：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。1234567891011121314public class ConstantClass &#123; static&#123; System.out.println(&quot;ConstantClass init!&quot;); &#125; public static final String HELLOWORLD = &quot;hello world!&quot;;&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; //System.out.println(SubClass.value); //SuperClass[] sca = new SuperClass[10]; System.out.println(ConstantClass.HELLOWORLD); &#125;&#125; 运行结果：1234&quot;D:\\Program Files (x86)\\Java\\jdk1.8.0_171\\bin\\java.exe&quot; ...hello world!Process finished with exit code 0 类加载过程加载 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机自身的安全。验证阶段大致分为以下四个：文件格式验证验证是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。只有这个阶段是基于二进制流的方式进行的，其他的阶段都是基于方法区的存储结构进行的。包括以下几个验证点： 是否以魔数0xCAFEBABE开头。 主、次版本号是否在当前虚拟机处理范围之内。 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。 Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 …元数据验证对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，包括以下几点： 是否有父类 父类是否继承了不允许被继承的类（final修饰） 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 类中的字段、方法是否与父类产生矛盾。 …字节码验证整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析确定程序语义是否是合法的、符合逻辑的。如以下几点： 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。 保证跳转指令不会跳转到方法体以外的字节码指令上。 保证方法体中的类型转换是有效的。 …符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段-解析阶段中发生。符号引用验证可以看做是对类自身以外的信息进行匹配性校验。通常校验以下内容： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的访问性是否可以被当前类访问。 …可以使用-Xveriy:none参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。准备正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。如：1public static int value = 123; 在准备阶段，value的初始值为0（通常情况下）,而不是123。因为这个时候尚未开始执行任何Java方法，而赋值为123的putstatic指令时程序被编译后，存放于类构造器,()方法中，所以把value赋值为123的动作是在初始化阶段才会执行。相对于通常情况下，有一些特殊情况。如果类字段的字段属性表中存在ConstantValue属性，那么就在准备阶段就会被赋值为ConstantValue的值。如：1public static final int value = 123; 编译时Javac将会为value生成ConstantValue属性，这段代码就会在准备阶段为value赋值为ConstantValue的值。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用(Symbolic References)：与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可能不同，但是能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用(Direct References)：与迅疾实现的内存布局相关，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在内存中。 类或接口解析 字段解析 类方法解析 接口方法解析初始化真正开始执行类中定义的Java程序代码（或者说是字节码），这是类加载过程的最后一步。 ()方法（执行类构造器方法）是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。收集顺序是由语句在源文件中出现的顺序所决定。静态语句块中只能访问定义在静态语句块之前的变量，定义在之后的比那辆，只能赋值，但不能访问。如以下代码所示： 1234567public class Test &#123; static&#123; i = 0;//正常编译 System.out.println(i);//报 illegal forward reference（非法向前引用） &#125; static int i = 1;&#125; ()方法与类的构造函数（或者说实例构造器()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行前，父类的()方法已经执行完毕。因此在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。 由于父类的()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如以下代码所示：123456789101112131415public class Test2 &#123; static class Parent&#123; public static int A = 1; static&#123; A = 2; &#125; static class Sub extends Parent &#123; public static int B = A; &#125; &#125; public static void main(String[] args) &#123; System.out.println(Parent.Sub.B); &#125;&#125; 运行结果：12 因为父类在进行初始化的时候，会在静态代码块中将A的赋值为2。因为这个过程顺序是优于子类的。 ()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值才做，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成()方法。只有当父接口中定义的变量使用时，父接口才会初始化。这与普通的类不同。接口的实现类在初始化时也一样不会执行接口的()方法。 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程会去执行这个类的()方法，其他线程阻塞。如以下代码所示：1234567891011121314151617181920212223242526public class Clinit &#123; static class DeadLoopClass &#123; static &#123; if (true) &#123; System.out.println(Thread.currentThread() + &quot;init DeadLoopClass&quot;); while (true) &#123; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Runnable script = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread() + &quot;start&quot;); DeadLoopClass dlc = new DeadLoopClass(); System.out.println(Thread.currentThread() + &quot;run over&quot;); &#125; &#125;; Thread thread1 = new Thread(script); Thread thread2 = new Thread(script); thread1.start(); thread2.start(); &#125;&#125; 运行结果如下，死循环：123Thread[Thread-1,5,main]startThread[Thread-0,5,main]startThread[Thread-1,5,main]init DeadLoopClass 类加载器类与类加载器判断两个类是否相等，是需要建立在同一个类加载器加载的前提下。也就是说，如果两个类的Class文件一样，被同一个虚拟机加载，只要他们的类加载器不同，那么这两个类必定不相等。相等包括： equals()方法 isAssignableFrom()方法 isInstance()方法的返回结果。 instanceof例：1234567891011121314151617181920212223242526272829package com.laowang.vm.classloader;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest &#123; public static void main(String[] args) throws Exception &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try&#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;)+1)+&quot;.class&quot;; InputStream is = getClass().getResourceAsStream(fileName); if(is == null)&#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125;catch (IOException e)&#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myLoader.loadClass(&quot;com.laowang.vm.classloader.ClassLoaderTest&quot;).newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof com.laowang.vm.classloader.ClassLoaderTest); &#125;&#125; 运行结果：1234class com.laowang.vm.classloader.ClassLoaderTestfalseProcess finished with exit code 0 双亲委派模型从Java虚拟机的角度来讲，只存在两种不同的类加载器： BootstrapClassLoader：启动类加载器，这个类加载器由C++语言实现，是虚拟机自身的一部分。 所有其他的类加载器：这些类加载器由Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。 但从Java开发人员的角度来看，类可以分为更细致一些，基本上分为以下3种系统提供的类加载器： BootstrapClassLoader：放在&lt;JAVA_HOME&gt;\\lib目录中，或者被-Xbootclasspath参数所指定的目录中，并且被虚拟机按照名字识别，名字不符合的即使放在lib目录下也不会被加载。 Extension ClassLoader：这个加载器由sun.misc.Laucher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录中的类库，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类的加载器。 Application ClassLoader：这个类加载器由sun.misc.Laucher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径classpath上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。双亲委派模型的工作过程如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的BootstrapClassLoader中，只有当父加载器反馈自己无法完成这个加载请求的时候，子加载器才会尝试自己去加载。比如，java.lang.Object类，它在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给BootstrapClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果不是双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个java.lang.Object类，并放在程序的classpath中，那系统中将会出现多个不同的Object，Java类型体系中最基础的行为也就无法保证。破坏双亲委派模型* JDK1.2以前 线程上下问类加载器（Thread Context ClassLoader） OSGi：Bundle实现热部署。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"字节码指令","slug":"字节码指令","date":"2016-10-28T02:24:00.000Z","updated":"2019-02-13T06:40:51.488Z","comments":true,"path":"Java/字节码指令/","link":"","permalink":"https://blog.mmzsblog.cn/Java/字节码指令/","excerpt":"","text":"Java虚拟机指令Java虚拟机指令的构成 一个字节长度 代表着某种特定操作含义的数字（称为操作码，Opcode） 跟随其后的零到多个代表此操作数所需的参数（称为操作数，Operands） Java虚拟机采用的是面向操作数栈而不是寄存器的架构 优点：放弃操作数长度对齐，可以省略很多填充和间隔符号。 缺点：在某种程度上会导致解释执行字节码时损失一些性能。字节码与数据类型 大多数指令都包含了其操作所对应的数据类型信息。 大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的卫子夫来表名专门为哪种数据类型服务。 i代表对int类型的数据操作 l代表long s代表short b代表byte c代表char f代表float d代表double a代表reference 也有一些指令的助记符中没有明确的指明操作类型的字母： 如arraylength，它没有代表数据类型的特殊字符，但是操作数也只能是个数组类型的对象。 还有一些指令，如goto则是与数据类型无关的。 因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它。也就是说，指令集将会故意被设计成非完全独立的。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，包括： 将一个局部变量加载到操作栈：iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_ 将一个数值从操作数栈存储到局部变量表：istore、istore_、lstore、lstore_、fstore、fstore_、dstore、dstore_、astore、astore_。 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_ml、iconst_、lconst_、fconst_、dconst_。 扩充局部变量表的访问索引的指令：wide。==注： 等，表示一组指令，如iload_ 代表iload_0,iload_1,iload_2和iload3这几条指令。==运算指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入操作栈顶。指令如下： 加法指令：iadd、ladd、fadd、dadd。 减法指令：isub、lsub、fsub、dsub。 乘法指令：imul、lmul、fmul、dmul。 除法指令：idiv、ldiv、fdiv、ddiv。 求余指令：irem、lrem、frem、drem。 取反指令：ineg、lneg、fneg、dneg。 位移指令：ishl、ishr、iushr、lshl、lshr、lushr。 按位或指令：ior、lor。 按位与指令：iand、land。 按位异或指令：ixor、lxor。 局部变量自增指令：iinc。 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。==注：byte、short、char和boolean类型没有直接支持的算数指令，对于这类数据的运算，应使用操作int类型的指令代替。==运算结果异常分析 数据运算可能导致溢出，如两个很大的正整数相加，结果可能会是一个负数。Java虚拟机规范没有明确定义整型数据溢出的具体运算结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整型数运算都不应该抛出运行时异常。 浮点数运算时，所有运算结果必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。 浮点数转换 为整数时，Java虚拟机使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃。 在处理浮点数运算时，不会抛出==任何运行时异常==，当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN来表示，所有使用NaN值作为操作数的算数操作，结果都会返回NaN。 在对long类型数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较时，虚拟机会采用无信号比较*方式。类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作。 直接支持宽化类型转换，及向上转，小转大。 int到long、float或者double类型。 long到float、double类型。 float到double类型。 处理窄化类型转换时，必须显式地使用转化指令来完成。这些指令包括： i2b i2c i2s l2i f2i f2l d2i d2l d2f但可能导致转换结果产生不同的正负号、不同的数量级，也可能导致数值的精度丢失。对象创建与访问指令虽然累实例和数组都是对象，但是Java虚拟机对类实例和数组的创建和操作使用了不同的字节码指令。指令如下： 创建对象指令：new 创建数组指令：newarray、anewarray、multianewarray 访问类字段和实例字段的指令：getfield、putfield、getstatic、putstatic 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。 取数组长度的指令：arraylength。 检查类实例类型的指令：instanceof、checkcast。操作数栈管理指令 将操作数栈的栈顶一个或两个元素出栈：pop、pop2。 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2. 将栈最顶端的两个数值互换：swap。控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令或不是控制转移指令的下一条指令继续执行程序。可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。指令如下： 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。 复合条件分支：tableswitch、lookupswitch。 无条件分支：goto、goto_w、jsr、jsr_w、ret。方法调用和返回指令 调用对象的实例方法：invokevirtual 调用接口方法：invokeinsterface 调用一些需要特殊处理的实例方法（实例初始化方法、私有方法和父类方法等）：invokespecial 调用静态方法（类方法）：invokestatic 在运行时动态解析出调用点限定符所引用的方法，并执行该方法：invokedynamic。异常处理指令显式抛出异常的操作（throw语句）都由athrow指令来实现。同步指令Java虚拟机可以支持方法及的同步和方法内部一段指令序列的同步，这两种同步结构都是使用Monitor来支持的。方法级的同步是隐式的，无需通过字节码指令来控制，它是现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声名为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED是否被设置，如果设置了，执行线程就要求先陈宫持有Monitor，然后才能执行这个方法，当方法完成时释放Monitor。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"类文件结构","slug":"类文件结构","date":"2016-10-27T02:24:00.000Z","updated":"2019-02-13T06:40:51.529Z","comments":true,"path":"Java/类文件结构/","link":"","permalink":"https://blog.mmzsblog.cn/Java/类文件结构/","excerpt":"","text":"Class类文件的结构概念 Class文件是一组以8位字节为基础单位的二进制流 按顺序整齐排列 没有分隔符 排序方式：高位在前 Big-Endian: 最高位字节在地址最低位、最低位字节在地址最高位。 Little-Endian：相反。存储方式 类似于C语言结构体的伪结构来存储 只有两种数据类型： 无符号数：属于基本数据类型 u1 : 1个字节 u2 : 2个字节 u4 : 4个字节 u8 : 8个字节 表：多个无符号数或其他表作为数据项构成的复合数据类型 以”_info”结尾。 描述有层次关系的复合结构数据 整个Class文件本质上就是一张表魔数 魔数 每个Class文件的头4个字节。 确定这个文件是不是一个能被虚拟机接受的Class文件 Java中的值为：0xCAFEBABE –&gt; 咖啡宝贝？Class文件的版本 紧接着的4个字节 第5个和第6个：次版本号（Minor Version） 第7个和第8个：主版本号（Major Version） 满足向下兼容，即高版本兼容低版本的Class文件常量池 紧接着版本号 Class文件中的资源仓库 常量池容量计数值（constant_pool_count） 常量池中常量数量不确定，所以需要一个计数 是u2类型的数据 从1开始而不是从0开始计数 设计者将0位做特殊考虑，特殊情况下，有些指向常量池的索引数据要表达“==不引用任何常量池项目==”的意义。 常量池容量（偏移地址：0x00000008）为十六进制数0x0016，十进制22，表示常量池中有21项常量，索引1~21。 主要存放类型 字面量(Literal)：如文本字符串、final常量等 符号引用(Symbolic References) 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 14种常量池的每个常量表 CONSTANT_Utf8_info 1 UTF-8包含的类型: u1 tag 1 标志位 u2 length 1 utf-8字符串的长度 u1 bytes length 真正的字符串内容 CONSTANT_Integer_info 3 整型 CONSTANT_Float_info 4 浮点型 CONSTANT_Long_info 5 长整型 CONSTANT_Double_info 6 双精 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串型 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的部分符号引用 CONSTANT_MethodHandle_info 15 方法句柄 CONSTANT_MethodType_info 16 标识方法类型 CONSTANT_InvokeDynamic_info 18 动态方法调用点 java代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455PS E:\\&gt; javac .\\TestClass.javaPS E:\\&gt; javap -verbose .\\TestClass.classClassfile /E:/TestClass.class Last modified 2018-8-9; size 293 bytes MD5 checksum a364fba0fc6304868b1a4cc1a3ba3729 Compiled from &quot;TestClass.java&quot;public class org.laowang.clazz.TestClass minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#16 // org/laowang/clazz/TestClass.m:I #3 = Class #17 // org/laowang/clazz/TestClass #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 TestClass.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 org/laowang/clazz/TestClass #18 = Utf8 java/lang/Object&#123; public org.laowang.clazz.TestClass(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 7: 0&#125;SourceFile: &quot;TestClass.java&quot; 访问标志(access_flags) 紧接着常量池 两个字节 总共16位，当前只定义了其中8个，未使用的一律为0 标志名称 标志值 含义 ACC_PUBLIC 0x0001 public ACC_FINAL 0x0010 final ACC_SUPER 0x0020 invokespecial（JDK1.0.2之后编译出来的类这个标志欧必须为真） ACC_INTERFACE 0x0400 abstract(接口或者类) ACC_SYNTHETIC 0x1000 并非由用户代码产生 ACC_ANNOTATION 0x2000 注解 ACC_ENUM 0x4000 枚举 类索引(this_class)、父类索引(super_class)与接口索引(interfaces)集合 紧接着访问标志 u2类型(this_class、super_class) u2类型集合(interfaces) 各索引的含义 这三项数据来确定类的继承关系 类索引(this_class)用来确定类全限定名 父类索引(super_class)用来确定父类的全限定名 接口索引描述类实现的接口，按从左到右的顺序排列。 父类索引(super_class)除了java.lang.Object外，其他的类都不为0。字段表集合(field_info) 描述接口或类中声名的变量 包含： 作用域(public private protected) 实例变量还是类变量(static) 可变性(final) 并发可见性(volatile) 序列化(transient) 字段数据类型 字段名称 全限定名，相当于类的全路径，只是把.换成/，如java/lang/Object 简单名称，方法或属性名的简写，如inc()方法和m属性，则简单名称为inc和m 描述符： 描述字段的数据类型、方法的参数列表和返回值。 基本数据类型和void都用一个大写字母来表示，对象类型用L加全限定名来表示 标识名称 含义 B byte C char D double F float I int J long S short Z boolean V void L 对象类型 数组描述符： 一维数组:String[] –&gt; [Ljava/lang/String 二维数组:String[][] –&gt; [[Ljava/lang/String 方法描述符： 参数列表在前，返回值在后的顺序 参数列表放在()内，如： void inc() 描述符为()V int indexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex) 描述为 ([CII[CIII)I方法表集合 包含 访问标志(access_flags) 名称索引(name_index) 描述符索引(descriptor_index) 属性表集合(attributes) 方法表集合中没有方法里面的代码，Java代码存在属性表集合中名为“Code”的属性里面 重写和重载的原理 重写(Override)：如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但是，有可能出现编译器自动添加的方法，如类构造器方法和实例构造器方法。 重载(Overload)：要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。因为返回值不会包含在特征签名中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有的方法进行重载。但在Class文件格式中，如果一个方法有相同的名称和特征签名，但返回值不同，也可以合法共存于同一个Class文件中。 特征签名：一个方法中各个参数在常量池中的字段符号引用的集合。属性表集合 描述某些场景的专有信息 没有太多顺序、长度、内容的限值 虚拟机规范预定于的属性 属性名 使用位置 含义 Code 方法表 Java代码编译成的字节码指令 ConstantValue 字段表 final关键字定义的常量 Deprecated 类、方法表、字段表 被声明为deprecated的方法和字段 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 只有当一个类是局部类或匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClasses 类文件 内部类列表 LineNumberTable Code属性 Java源码的行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部变量描述 StackMapTable Code属性 JDK1.6新增，供新的类型检查验证器检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 Signature 类、方法表、字段表 JDK1.5新增，支持泛型情况下的方法签名 SourceFile 类文件 记录源文件名 SourceDebugExtension 类文件 JDK1.6新增，用于存储额外的调试信息 Synthetic 类、方法表、字段表 标识方法或字段为编译器自动生成的 LocalVarialbleTypeTable 类 JDK1.5新增，使用特征签名代替描述符 RuntimeVisibleAnnotations 类、方法表、字段表 JDK1.5新增，为动态注解提供支持，指明哪些注解是运行时可见的 RuntimeInvisibleAnnotations 类、方法表、字段表 JDK1.5新增，指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotations 方法表 JDK1.5新增，与RuntimeVisibleAnnotations类似，只不过作用对象为方法参数 RuntimeInvisibleParameterAnnotations 方法表 JDK1.5新增，与RuntimeInvisibleAnnotations类似，只不过作用对象为方法参数 AnnotationDefault 方法表 JDK1.5新增，用于记录注解类元素的默认值 BootstrapMethods 类文件 JDK1.7新增，用于保存invokedynamic指令引用的引导方法限定符 Code属性 Java编译器处理后的字节码指令存储在Code属性内 Code属性出现在方法表的属性集合中 并非所有的方法表都必须存在这个属性 结构 类型 名称 数量 u2 attribute_name_index：指向CONSTANT_UTF8_info型常量的索引 1 u4 attribute_length：属性值的长度 1 u2 max_stack：操作数栈的最大深度 1 u2 max_locals：局部变量表所需的存储空间 1 u4 code_length：编译后的字节码指令长度 1 u1 code：编译后的字节码指令流 code_length u2 exception_table_length：异常表长度 1 excpetion_info exception_table：异常表内容 excpetion_table_length u2 attributes_counts： 属性数量 1 attribute_info attributes： 属性内容 attributes_counts Code属性是Class文件中最重要的一个属性，如果把Class文件就分为代码（Code）和元数据（Metadata）两部分。那么Code可以解释为描述代码，元数据解释为其他数据。 attribute_name_index：固定为“Code”，表示该属性的名字 attribute_length：由于属性名和属性长度一共6个字节（u2+u4），所以属性值的长度就是整个属性表的长度减去这两个属性。 max_stack：在方法执行的任意时刻，操作数栈都不会超过这个长度。虚拟机运行的时候根据这个值来分配栈帧中的操作栈深度。 max_locals：单位是Slot，是虚拟机为局部变量分配内存的最小单位。（参考对应01、虚拟机 VM Stack） Slot可重用：并不是方法中使用了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals。当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用。 code_length：code_length代表编译后的字节码长度，code是存储字节码指令的一系列字节流。 exception_table_length：不是必须存在的。this关键字 在任何实例方法里面，都可以通过this关键字访问到此方法所属的对象。 它的实现其实非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。 因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量。 局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。这个处理只对实例方法有效，而对静态方法无效。 例： 有效： 12345678910package org.laowang.clazz;public class TestClass&#123; private int m; public int inc()&#123; return m+1; &#125; &#125; 无效： 12345678910package org.laowang.clazz;public class TestClass&#123; private static int m; public static int inc()&#123; return m+1; &#125; &#125; Exceptions属性列举出方法中可能抛出的受查异常（Checked Exceptions），也就是方法描述时在throws关键字后面列举的异常。结构如下：类型 | 名称 | 数量—|—|—u2 | attribute_name_index | 1u4 | attribute_length | 1u2 | number_of_exceptions | 1u2 | exception_index_table | number_of_exceptions LineNumberTable属性 描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。 不是运行时必须的属性，但默认会生成到Class文件中 可以在Javac中分别使用-g:none或-g:lines来取消或者要求生成这项信息。 如果不生成这个属性，最大的影响是当抛出异常时，堆栈中部会显示出错的行号，并且在调试的时候，也无法按照源码来设置断点。LocalVariableTable属性 描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系 不是运行时必须的属性，但是会默认生成到Class文件中。 可以在Javac中分别使用-g:none或-g:vars来取消或者要求生成这项信息。 如果不生成这个属性，最大的影响是当其他人引用这个方法时，所有的参数名称都回丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，但对程序运行没有影响。SourceFile属性 记录生成这个Class文件的源码文件名称。 可选的属性。 可以在Javac中分别使用-g:none或-g:source来关闭或者要求生成这项信息。 如果不开启，最大的影响是内部类抛出异常的时候，堆栈中将不会显示出错代码所属的文件名。ConstantValue属性 通知虚拟机自动为静态变量赋值。 如果是非静态变量，赋值是在方法中。 如果是静态： 如果是被final static修饰的一个变量，并且是基本类型或者是String类型，就要生成ConstantValue来进行初始化。 如果没有被final修饰或者不是基本类型及字符串，则会选择在方法中进行初始化。InnerClasses属性 记录内部类与宿主类之间的关联。 如果一个类定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。Deprecated及Synthetic属性 Deprecated： 使用@Deprecated注解进行设置，表示不再推荐使用，过时了。 Synthetic：表示字段或方法并不是由Java源码直接产生的，而是由编译器添加的。StackMapTable属性*Signature属性*BootstrapMethods属性*","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"虚拟机性能监控与JDK可视化工具","slug":"虚拟机性能监控与JDK可视化工具","date":"2016-10-26T02:24:00.000Z","updated":"2019-02-13T06:40:51.535Z","comments":true,"path":"Java/虚拟机性能监控与JDK可视化工具/","link":"","permalink":"https://blog.mmzsblog.cn/Java/虚拟机性能监控与JDK可视化工具/","excerpt":"","text":"JDK命令行工具jps(JVM Proccess Status Tool) 显示指定系统内所有HotSpot虚拟机进程 参数 -q 只输出LVMID(Local Virtual Machine Identifier)，省略主类名 -m 输出虚拟机进程启动时传递给主类main()函数的参数 -l 输出全路径名，如果是jar则输出jar的全路径 -v 输出虚拟机进程启动时JVM参数jstat(JVM Statistics Monitoring Tool) 收集HotSpot虚拟机各方面的运行数据 命令格式： 1jstat [option vmid [interval[s|ms] [count]] option：用户想要查询的虚拟机信息 -class 监视类装载、卸载数量、总空间及类装载耗时 -gc 监控Java堆状况，包括eden、survivor、老年代、永久代等容量、已用空间、GC时间合计等信息 -gccapacity 与-gc差不多，但输出主要关注Java堆各个区域使用到的最大、最小空间 -gcutil 与-gc差不多，但输出主要关注已使用空间占总空间的百分比 -gccause 与-gcutil一样，但是会多输出导致上次GC的原因 -gcnew 监视新生代GC状况 -gcnewcapacity 与-gcnew差不多，但输出主要关注使用到的最大、最小空间 -gcold 监视老年代GC装快 -gcoldcapacity 与-gcold差不多，但输出主要关注使用到的最大、最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出JIT编译过的方法、耗时等信息 -printcompilation 输出已经被JIT编译的方法 VMID和LVMID的区别：如果是本地则两个一样；如果是远程虚拟机，则VMID为： 1[protocol:][//lvmid[@hostname[:port]/servername] 例：假如每250ms查询一次进程2764的垃圾收集情况，一共查询20次，命令为： 1jstat -gc 2764 250 20 jinfo(Configuration Info for Java) 显示虚拟机配置信息 格式1jinfo [option] pid jmap(Memory Map for Java) 生成虚拟机的内存存储快照（heapdump文件） 命令格式 1jmap [option] pid option参数 -dump 生成Java堆转储快照，格式为：-dump:[live,]format=b,file=，其中live子参数说明是否只dump出存活的对象 -finalizerinfo 显示在F-Queue中等待Finalizer线程执行finalize方法，只在linux/Solaris平台下有效 -heap 显示Java堆详细信息，只在linux/Solaris平台下有效 -histo 显示堆中对象统计信息， 包括类、实例数量、合计容量 -permstat 以ClassLoader为统计口径显示永久代内存状态。只在linux/Solaris平台下有效 -F 当虚拟机进程对-dump选项没有响应时，可以使用这个强制生成。只在linux/Solaris平台下有效jhat(JVM Heap Dump Browser) 用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以再浏览器上查看分析结果（耗时长，不推荐使用）jstack(Stack Trace for Java) 显示虚拟机线程快照 命令格式 1jstack [option] vmid option 参数： -F 当正常输出的请求不被响应时，强制输出线程堆栈 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用到本地方法，可显示C/C++的堆栈HSDIS:JIT生成代码反汇编JDK可视化工具JConsoleVisualVM","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"GC与内存分配策略","slug":"GC与内存分配策略","date":"2016-10-25T02:24:00.000Z","updated":"2019-02-13T06:40:51.440Z","comments":true,"path":"Java/GC与内存分配策略/","link":"","permalink":"https://blog.mmzsblog.cn/Java/GC与内存分配策略/","excerpt":"","text":"GC算法早期GC算法引用计数法可达性分析算法当对象到GC Roots没有任何引用链相连时，此时对象是不可达的。此时该对象并不是“非死不可”，此时它暂时处于“缓刑”状态。第一次会被标记并且进行一次筛选，筛选的条件是对象是否有必要执行finalize()方法。以下两种情况会被视为没有必要执行： 对象没有覆盖finalize()方法 finalize()方法已经被虚拟机调用过 如果对象被判定为有必要执行finalize()方法，在此方法的执行过程中，对象与引用链上任何对象发生关联，则此对象可在第二次标记的时候移出即将回收的集合。相反，如果还没有发生关联，则此时被真正回收。 引用的概念 JDK1.2以前 引用 非引用 JDK1.2以后 强引用： 普遍存在，类似“Object obj = new Object()”。只要强引用还在，则不会被GC。 软引用(Soft Reference)： 有用但并非必须的对象。这些对象在程序将要发生OOM之前进行二次回收。如果二次回收还没有足够内存，则抛OOM异常。 弱引用： 比Soft Reference更弱，这些对象只能活到下次GC之前。在GC的时候，无论内存是否足够，都会将此引用对象回收。 虚引用(PhantomReference)： 最弱的引用关系，其作用是在虚引用关联的对象被GC时会收到一个系统通知。123456789101112131415161718192021222324252627282930313233343536373839404142 /** * 此代码的功能： * 1 对象可以在被GC时自我拯救 * 2 自我拯救的机会只有一次，因为一个对象的finalize()方法只能被系统自动调用一次 */public class FinalizeEspaceGC &#123; public static FinalizeEspaceGC SAVE_HOOK = null; public void isAlive()&#123; System.out.println(&quot;yes,i am still alive!&quot;); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(&quot;finalize method executed!&quot;); FinalizeEspaceGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws Throwable&#123; SAVE_HOOK = new FinalizeEspaceGC(); //对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); //因为finalize()方法优先级很低，暂停0.5秒 Thread.sleep(500); if(SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125;else &#123; System.out.println(&quot;no,i am dead!&quot;); &#125; //下面代码与上面完全一样，但是这次却自救失败了 SAVE_HOOK = null; System.gc(); //因为finalize()方法优先级很低，暂停0.5秒 Thread.sleep(500); if(SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125;else &#123; System.out.println(&quot;no,i am dead!&quot;); &#125; &#125;&#125; 回收方法区主要包括两个部分： 废弃常量：如果常量池中的某个字符串在系统中没有任何一个String对象的引用，那么如果发生内存回收，则此常量会被系统清理出常量池。 无用的类：满足以下三个条件： 该类的所有实例已经被回收 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法GC算法标记-清除法首先标记，然后在GC的时候清除标记的对象。不足之处： 标记和清除两个过程的效率都不高 空间问题，标记清楚后会产生大量不连续的内存碎片复制算法 将可用内存划分为大小相等的两块，每次只是用其中一块 当这块内存用完后，将存活的对象复制到另一块内存中 将已使用的内存空间清理掉改进复制算法由于新生代的迭代速率较快，所以内存不需要按照1：1的比例划分。而是将内存分为一块较大的Eden区域和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。标记-整理算法让所有存活的对象往内存一端移动，然后清理掉边界以外的内存。分代收集算法根据对象存活周期不同将内存分为几块： 新生代 老年代 根据各个年代的特点采用最适当的收集算法。 HotSpot可达性分析枚举根节点GC停顿在整个分析期间，为了保证分析准确性，整个分析过程中，对象引用不能变化。因此,GC时必须停顿所有的Java执行线程。 OopMap 执行系统停顿下来时，不需要检查完所有执行上下文及全文引用位置，而使用OopMap。 类加载完成时，HotSpot会记录偏移量上的类型供GC扫描。SafePoint 程序并非在所有位置都停顿下来进行GC，只有在达到SafePoint时才暂停。 SafePoint不能太少导致GC等待时间过长，SafePoint不能太多导致GC花费更多内存空间。 选取标准：是否具有让程序长时间执行的特征。抢断式中断 首先将所有线程中断，如果有线程中断的地方不在SafePoint上则恢复，让它跑到SafePoint上。 现在几乎没有虚拟机采用主动式中断 当GC需要中断线程的时候，不直接对线程操作，而是设置一个标志，各个线程主动轮询这个标志，如果发现中断标志为真，则自己中断挂起。SafeRegion在一段代码片段中，引用关系不会发生变化。在这个区域中任意地方开始GC都是安全的。垃圾收集器算法是方法论，而垃圾收集器就是具体实现。并行和并发 并行：多个垃圾收集器线程同时运行，但是用户线程暂停。 并发：垃圾收集器线程和用户线程同时运行，但是不是同一个CPU处理。Serial收集器 最基本、发展历史最悠久 新生代收集器 单线程收集器 Client模式下首选ParNew收集器 Serial收集器的多线程版 新生代收集器 Server模式下首选Parallel Scavenge 收集器 新生代收集器 并行多线程收集器 目的是达到一个可控制的吞吐量，而不是关注于缩短用户线程的停顿时间。 吞吐量=运行用户代码时间/（运行用户代码时间 + 垃圾收集时间） 精确控制吞吐量的参数： 控制最大垃圾收集停顿时间，大于0的毫秒数。并不是设置的小就能使系统垃圾收集速度变快。 1-XX:MaxGCPauseMillis 直接设置吞吐量大小，0到100的整数。 1-XX:GCTimeRatio GC自适应调节策略：根据当前系统运行情况收集性能监控信息，动态调整新生代大小、Eden与Survivor区比例、老年代对象年龄等参数，无需手工设置。提供最合适的停顿时间或者最大的吞吐量。 12#开关参数-XX:+UseAdaptiveSizePolicy Serial Old收集器 Serial收集器的老年代版本 单线程收集器 使用标记整理算法 主要是Client端虚拟机使用 如果在Server模式下，主要有两大用途： JDK1.5及之前的版本，配合Parallel Scavenge使用。 作为CMS的后备预案，在并发收集发生Concurrent Mode Failure时使用。Parallel Old收集器 Parallel Scavenge 收集器的老年代版本 多线程收集器 使用标记整理算法CMS(Concurrent Mark Sweep)收集器 以获取最短回收停顿时间为目标 使用标记清除算法 运作过程如下： 初始标记(CMS initial mark)：标记GC Roots能直接关联到的对象，速度很快。 并发标记(CMS concurrent mark)：进行GC Roots Tracing的过程 重新标记(CMS remark)：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记稍长，但远比并发标记时间短。 并发清除(CMS concurrent sweep)： 总体来说，CMS收集器的内存回收过程是与用户线程并发执行的。 CMS的三个明显缺点 CPU大于4个时，CMS回收垃圾线程随着CPU数量的增加而减少；而当CPU少于4个时，CMS对用户程序的影响就可能变得很大。 增量式并发收集器(Incremental Concurrent Mark Sweep /i-CMS)：但是效果一般，不推荐使用。 无法处理浮动垃圾，Concurrent Mode Failure会导致另一次Full GC产生而只能将这部分回收失败的垃圾留在下次GC再清理。因此CMS必须预留一部分空间提供给并发收集时的程序使用。 JDK1.5默认设置老年代使用86%后激活CMS收集器，如果应用中老年代增长不是太快，可以调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比。 JDK1.6中，CMS启动阈值已经提高到92%。 如果运行期间预留的内存不够CMS，就会出现Concurrent Mode Failure，此时会启动后备预案：临时启用Serial Old收集器重新进行老年代垃圾收集，这样会导致停顿时间很长。 因此，参数-XX:CMSInitiatingOccupancyFraction设置的太高容易导致大量Concurrent Mode Failure，性能反而会降低。 标记清除算法会产生很多的内存碎片。 CMS提供了一个-XX:UseCMSCompactAtFullCollection开关参数，默认开启，用于在CMS收集器顶不住Full GC时，开启内存碎片合并整理过程，这个过程无法并发，因此停顿时间会变长。 虚拟机还提供了另一个参数-XX:CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后进行一次压缩的Full GC（默认为0，表示每次进入Full GC时都进行碎片整理）。G1 收集器 当今收集器技术发展最前沿的成果之一 面向服务端应用 具有以下特点 并行和并发 分代收集 将Java堆划分为多个大小相等的独立区域（Region），新生代和老年代的概念还在，只是不再是物理隔离，而是一部分Region的集合。 空间整合 可预测的停顿 使用Remembered Set来避免在整个Java堆中进行全区域的垃圾收集。 G1跟踪各个Region里的垃圾堆积的价值大小（回收所获得的空间及回收所需的时间），后台维护一个优先列表。 每次根据允许的收集时间，优先回收价值最大的Region（Garbage-First）。 G1收集器运作大致可划分为以下步骤： 初始标记(Initial Marking) 并发标记(Concurrent Marking) 最终标记(Final Marking) 筛选回收(Live Data Counting and Evacuation)理解GC日志1233.125:[GC [DefNew: 3324K-&gt;152K(3712K),0.0025925 secs] 3324K-&gt;152K(11904K) 0.0031680 secs]100.667:[Full GC [Tenured: 0K-&gt;210K(10240K),0.0149142 secs]4603K-&gt;210K(19456K),[Perm : 2999K-&gt;2999K(21248K)],0.0150007 secs][Times:user=0.01 sys=0.00,real=0.02 secs] 最前面的数字 33.125: 和 100.667： 表示GC发生的时间，含义是从Java虚拟机启动以来经过的秒数 GC日志开头的 [GC 和 [Full GC： 说明这次垃圾收集的停顿类型，而不是区分新生代GC还是老年代GC 如果有Full说明是发生了停顿（Stop-The-World） 接下来的 [DefNew 、[Tenured 、 [Perm 表示GC发生的区域。 DefNew -&gt; Defualt New Generation Serial收集器的新生代 ParNew -&gt; Parallel New Generation Parallel Scavenge收集器的新生代 后面方括号内部的3324K-&gt;152K(3712K)： 表示GC前该内存已使用量 -&gt; GC后该内存区域已使用量 (该内存区域总容量) 方括号外3324K-&gt;152K(11904K)： 表示GC前Java堆已使用量 -&gt; GC后Java堆已使用量 (Java堆总容量) 0.0031680 secs： 表示该内存区域GC所占用的时间，单位为秒。 有的收集器会给出更具体的数据，如[Times : user=0.01 sys=0.00,real=0.02 secs] 这里面的user、sys、real与Linux的time命令所输出的时间含义一致。 user 用户消耗CPU的时间 sys 内核消耗CPU的时间 real 操作从开始到结束所经过的墙钟时间（Wall Clock Time） GC常用参数总结 参数 描述 UseSerialGC 虚拟机在Client下的默认值，打开后，使用Serial + Serial Old进行内存回收 UseParNewGC 打开后，使用ParNew + Serial Old进行内存回收 UseConcMarkSweepGC 打开后，使用ParNew + CMS + Serial Old（CMF备用）进行内存回收。 UseParallelGC 虚拟机在Server模式下的默认值，打开后，使用Parallel Scavenge + Serial Old进行内存回收 UseParallelOldGC 打开后，使用Parallel Scavenge + Parallel Old 进行内存回收 SurvivorRatio 新生代中Eden与Survivor的容量比，默认为8，代表：Eden：Survivor=8：1 PretenureSizeThreshold 直接晋升到老年代的对象大小 MaxTenuringThreshold 晋升到老年代的对象年龄。每经过一次Minor GC后年龄加1 UseAdaptiveSizePolicy 动态调整Java堆中各个区域的大小及进入老年代的年龄 HandlePromotionFailure 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 ParallelGCThreads 设置并行GC时进行内存回收的线程数 GCTimeRatio GC时间占总时间的比率，默认为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 MaxGCPauseMillis 设置GC最大停顿时间。仅在使用Parallel Scavenge收集器时生效 CMSInitiatingOccupancyFraction 设置CMS在老年代空间被使用多少后触发垃圾收集。仅在使用CMS收集器时生效 UseCMSCompactAtFullGollection 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 CMSFullGCsBeforeCompaction 设置CMS收集器在进行若干次GC后再启动一次内存碎片整理。仅在使用CMS收集器时生效 内存分配与回收策略对象内存分配，可能分为以下几种情况：堆：大多数分配在堆上 Eden TLAB：如果启动了本地线程分配缓冲，优先在TLAB上分配 Tenured：有可能直接分配在老年代中栈：JIT编译有可能间接分配在栈上代码测试Serial / Serial Old收集器 代码 12345678910111213141516171819/** * VM Args: * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCdetails -XX:SurvivorRatio=8 * -verbose:gc 输出GC的详细情况 * -Xms20M -Xmx20M 限值Java堆大小为20MB * -Xmn10M 新生代10M * -XX:+PrintGCdetails 打印内存回收日志 * -XX:SurvivorRatio=8 Eden区与Survivor区的内存比8:1 */public class Serial &#123; private static final int _1MB = 1024 * 1024; public static void testAllcation()&#123; byte[] allocation1,allocation2,allocation3,allocation4; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation4 = new byte[4 * _1MB]; //出现一次Minor GC &#125;&#125; 运行结果： 123456789101112&quot;D:\\Program Files (x86)\\Java\\jdk1.8.0_171\\bin\\java.exe&quot; -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 &quot;...&quot; com.laowang.vm.allocation.Serial[GC (Allocation Failure) [DefNew: 7474K-&gt;583K(9216K), 0.0039100 secs] 7474K-&gt;6727K(19456K), 0.0227873 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap def new generation total 9216K, used 4843K [0x07400000, 0x07e00000, 0x07e00000) eden space 8192K, 52% used [0x07400000, 0x078290f8, 0x07c00000) from space 1024K, 56% used [0x07d00000, 0x07d91cc8, 0x07e00000) to space 1024K, 0% used [0x07c00000, 0x07c00000, 0x07d00000) tenured generation total 10240K, used 6144K [0x07e00000, 0x08800000, 0x08800000) the space 10240K, 60% used [0x07e00000, 0x08400030, 0x08400200, 0x08800000) Metaspace used 211K, capacity 2280K, committed 2368K, reserved 4480KProcess finished with exit code 0 大对象直接进入老年代 代码 12345678910111213141516/** * VM Args: * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 * -XX:PretenureSizeThreshold=3145728 设置大于3MB的对象直接进入老年代，这里不能直接写3MB */public class Tenured &#123; private static final int _1MB = 1024 * 1024; public static void testPretenureSizeThreshold()&#123; byte[] allocation; allocation = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testPretenureSizeThreshold(); &#125;&#125; 运行结果 1234567891011&quot;D:\\Program Files (x86)\\Java\\jdk1.8.0_171\\bin\\java.exe&quot; -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728 &quot;...&quot; com.laowang.vm.allocation.TenuredHeap def new generation total 9216K, used 1494K [0x07600000, 0x08000000, 0x08000000) eden space 8192K, 18% used [0x07600000, 0x07775ab0, 0x07e00000) from space 1024K, 0% used [0x07e00000, 0x07e00000, 0x07f00000) to space 1024K, 0% used [0x07f00000, 0x07f00000, 0x08000000) tenured generation total 10240K, used 4096K [0x08000000, 0x08a00000, 0x08a00000) the space 10240K, 40% used [0x08000000, 0x08400010, 0x08400200, 0x08a00000) Metaspace used 210K, capacity 2280K, committed 2368K, reserved 4480KProcess finished with exit code 0 长期存活的直接进入老年代 代码 123456789101112131415161718192021/** * VM Args: * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 * -XX:MaxTenuringThreshold=1 经过1次GC后进入Survivor的对象没被回收，第二次就直接进入tenured * -XX:+PrintTenuringDistribution 打印 */public class TenuringThreshold &#123; private static final int _1MB = 1024 * 1024; public static void testTenuringThreshold()&#123; byte[] allocation1,allocation2,allocation3; allocation1 = new byte[_1MB / 4]; allocation2 = new byte[4 * _1MB]; allocation3 = new byte[4 * _1MB]; allocation3 = null; allocation3 = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testTenuringThreshold(); &#125;&#125; 运行结果 123456789101112131415161718&quot;D:\\Program Files (x86)\\Java\\jdk1.8.0_171\\bin\\java.exe&quot; -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution &quot;...&quot; com.laowang.vm.allocation.TenuringThreshold[GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 1 (max 1)- age 1: 886848 bytes, 886848 total: 5682K-&gt;866K(9216K), 0.0037215 secs] 5682K-&gt;4962K(19456K), 0.0037612 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 1 (max 1): 4962K-&gt;0K(9216K), 0.0010335 secs] 9058K-&gt;4955K(19456K), 0.0010503 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 4178K [0x07200000, 0x07c00000, 0x07c00000) eden space 8192K, 51% used [0x07200000, 0x07614938, 0x07a00000) from space 1024K, 0% used [0x07a00000, 0x07a00000, 0x07b00000) to space 1024K, 0% used [0x07b00000, 0x07b00000, 0x07c00000) tenured generation total 10240K, used 4955K [0x07c00000, 0x08600000, 0x08600000) the space 10240K, 48% used [0x07c00000, 0x080d6ea8, 0x080d7000, 0x08600000) Metaspace used 219K, capacity 2280K, committed 2368K, reserved 4480KProcess finished with exit code 0 动态对象年龄判断 当Survivor中的相同年龄的所有对象大小总和大于Survivor的一半时，年龄大于或等于该年龄的对象就可以直接进入老年代。不用等到MaxTenuredThreshold设置的值。空间分配担保 在Minor GC之前，虚拟机会先检查老年代的连续内存空间够不够新生代所有对象的内存空 如果够，那么Minor GC保证是安全的。 如果不够，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许，则会继续检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均水平。 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的 如果小于或者HandlePromotionFailure设置不允许冒险，那么就会进行一次Full GC。“冒险”的概念 当大量对象在Minor GC后仍然存活，就需要老年代进行分配担保 把Survivor无法容纳的对象直接进入老年代 要进行这样的担保，首先要保证老年代的空间足够容纳这些对象 对象有多少能够最终存活下来在实际完成内存回收之前无法确定，所以只有按照以前晋升老年代的对象容量的平均值做参考 如果不够，再确定是否需要进行Full GC来腾出更多空间","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"JVM内存划分及OOM分析","slug":"JVM内存划分及OOM分析","date":"2016-10-24T02:24:00.000Z","updated":"2019-02-13T06:40:51.454Z","comments":true,"path":"Java/JVM内存划分及OOM分析/","link":"","permalink":"https://blog.mmzsblog.cn/Java/JVM内存划分及OOM分析/","excerpt":"","text":"Java内存区域与内存溢出异常运行时数据区域Java在运行时会把它所管理的内存划分为若干个不同的数据区域。 方法区(Method Area) 线程共享 存储 类信息 常量 静态变量 即时编译器编译后的代码 非堆 不需要连续的内存 可以选择固定或可扩展 可选择不实现垃圾收集 针对常量池的回收 运行时常量池（Runtime Constant Pool） 常量池：存放编译期生成的字面常量和符号引用 这些常量池中的数据进入方法区后存放在运行时常量池中 动态性：运行期可将新的常量放入池中，例如：String.intern()方法 对类型的卸载 无法满足内存分配需求时会抛出OutOfMemoryError虚拟机栈(VM Stack) 线程私有 生命周期与线程相同 描述Java方法执行的内存模型 栈帧 存储 局部变量表：基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址） 64位的long 和double会占用两个局部变量空间，其余的只占一个 编译期完成内存分配 方法运行期间不会改变局部变量表的大小 操作数栈 动态链接 方法出口 入栈 出栈 线程请求的栈深度大于虚拟机允许的深度会抛出StackOverFlowError 如果扩展时无法申请到足够内存会抛出OutOfMemoryError本地方法栈(Native Method Stack) 为本地方法(Native Method)服务 区别于虚拟机栈：为虚拟机执行Java方法服务。 抛出StackOverFlowError 抛出OutOfMemoryError堆(Heap) Java虚拟机所管理的内存中最大的一块 线程共享 虚拟机启动时创建 存放对象实例及数组 垃圾回收管理（GC）主要区域 分代算法 新生代 eden from to 老年代 可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB） 可处于物理上不连续的内存空间，保证逻辑连续即可 可通过-Xmx和-Xms控制大小（可扩展） 堆无法再扩展时会抛出OutOfMemoryError程序计数器（Program Counter Register） 较小内存空间 当前线程的行号指示器 线程私有的内存 唯一一个没有OutOfMemoryError的区域直接内存(Direct Memory) NIO中使用基于通道（Channel）与缓冲区（Buffer）的I/O方式，使用Native函数库直接分配的堆外内存 无法满足内存分配需求时会抛出OutOfMemoryError对象的创建 类加载检查机制 为新生对象分配内存 把一块确定大小的内存从堆中划分出来。 内存规整： 指针碰撞（Bump the Point） 内存不规整 空闲列表（Free List）：维护列表并记录哪些是可用的。 选择方式由Java堆是否规整决定 Java堆是否规整由垃圾收集器是否带有压缩整理功能决定。 由于对象创建是非常频繁的，则在并发情况下不是线程安全的 对分配内存空间的动作进行同步处理 把内存分配的动作按照线程划分在不同的空间中，即TLAB方式。 只有在TLAB用完并分配新TLAB的情况下需要同步锁定 可以使用-XX:+/-UseTLAB来设定 将分配到的内存空间初始化为0(不包含对象头) 对对象进行必要的设置 属于哪个类的实例 如何找到类的元数据信息 对象的哈希值 对象的GC分代年龄 这些数据存放在对象头（Object Header）中 对象得到创建，但是所有的字段为零，在执行new之后会立即执行方法对象的内存布局 对象头(Object Header) 存储对象自身运行时数据（Mark Word），通常在32位和64位的机器上占用32bit和64bit的空间 哈希吗 GC分代年龄 锁状态标志 线程持有锁 偏向线程ID 偏向时间戳 类型指针： 对象指向它的类元数据的指针 虚拟机通过这个指针来确定这个对象属于哪个类 不是所有的对象实例都保留有类型指针 如果对象是数组，还必须有一块用于记录数组长度的数据 实例数据（Instance Data），真正存储的数据 存储顺序受到虚拟机分配策略参数（Fields Allocation Style）和字段在Java源码中的定义顺序影响 对齐填充(Padding) 不是必要存在的 仅仅起占位作用对象访问定位 Java通过栈上的引用(reference)数据来操作堆上的具体对象句柄访问 堆中划分一块内存作为句柄池 reference中存储对象的句柄地址 句柄中包含对象实例数据与类型数据各自的具体地址信息 优点：reference中存储稳定的句柄地址，在对象移动时只会改变句柄中的实例数据指针直接指针 考虑如何放置访问类型数据的相关信息 reference中直接存储对象地址 优点：速度更快，节省一次指针定位的时间内存溢出测试(OutOfMemoryError)Java堆溢出 12345678910111213/** * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError */public class HeapOOM &#123; static class OOMObject&#123;&#125; public static void main(String[] args) &#123; System.out.println(&quot;test&quot;); List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); while (true)&#123; list.add(new OOMObject()); &#125; &#125;&#125; 结果123java.lang.OutOfMemoryError: Java heap spaceDumping heap to java _pid3404.hprof ...Heap dump file created [22045981 bytes in 0.663 secs] 分析 内存泄露 导致GC无法自动回收 分析与GC Roots 相关联的路径 内存溢出 检查虚拟机堆参数（-Xmx与-Xms） 虚拟机栈与本地方法栈溢出 1234567891011121314151617181920/** * VM Args: -Xss128k */public class StackOverFlow &#123; private int stackLength = 1; public void stackLeak()&#123; stackLength ++; stackLeak(); &#125; public static void main(String[] args) &#123; StackOverFlow oom = new StackOverFlow(); try&#123; oom.stackLeak(); &#125;catch (Throwable e)&#123; System.out.println(&quot;stack length:&quot;+oom.stackLength); throw e; &#125; &#125;&#125; 结果1234567Exception in thread &quot;main&quot; java.lang.StackOverflowErrorstack length:2271 at com.laowang.vm.StackOverFlow.stackLeak(StackOverFlow.java:9) at com.laowang.vm.StackOverFlow.stackLeak(StackOverFlow.java:10) at com.laowang.vm.StackOverFlow.stackLeak(StackOverFlow.java:10) at com.laowang.vm.StackOverFlow.stackLeak(StackOverFlow.java:10) 以下省略..... 方法区和运行时常量溢出12345678910111213141516/** * VM Args -XX:PermSize=10M -XX:MaxPermSize=10M * jdk1.6以前的版本，常量池分配在永久代，可以使用以上的参数来限值方法区的大小。 * jdk1.7以后逐步 ”去永久代“ */public class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; //使用List保持着常量池引用，避免Full GC回收常量池行为 List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true)&#123; //intern()方法的作用是如果常量池中有则返回，如果没有则放入常量池再返回 list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 结果123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native method) at com.laowang.vm.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:10) 引申：String.intern()返回引用测试12345678public class StringIntern &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString(); System.out.println(str2.intern() == str2); &#125;&#125; 结果12jdk1.6：false falsejdk1.7: true false 分析 jdk1.6： intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中实例的引用 StringBuilder创建的字符串实例在堆上 不是同一个引用，所以都是false jdk1.7： intern()方法不会复制实例，只是在常量池中记录首次出现的实例引用 是同一个引用方法区OOM代码12345678910111213141516171819202122/** * VM Args -XX:PermSize=10M -XX:MaxPermSize=10M * 同样在jdk1.7以后没有效果 * 在jdk1.6以前会出现OOM */public class JavaMethodAreaOOM &#123; public static void main(final String[] args) &#123; while(true)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(objects,args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject&#123; &#125;&#125; 结果12345Caused by: java.lang.OutOfMemoryError: PermGen space at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) at java.lang.ClassLoader.defineClass(ClassLoader.java:616) ... 8 more 本机直接内存溢出 直接内存可以使用 -XX:MaxDirectMemorySize 指定 默认与Java堆最大值( -Xms 指定)一样123456789101112131415/** * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M */public class DirectMemoryOOM &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); while(true)&#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 结果123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError at sun.misc.Unsafe.allocateMemory(Native Method) at com.laowang.vm.DirectMemoryOOM.main(DirectMemoryOOM.java:18)","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"https://blog.mmzsblog.cn/tags/JVM虚拟机/"}]},{"title":"注解","slug":"注解","date":"2014-11-23T06:46:53.000Z","updated":"2019-02-13T06:40:51.513Z","comments":true,"path":"Java/注解/","link":"","permalink":"https://blog.mmzsblog.cn/Java/注解/","excerpt":"","text":"Annotation 注解如同标签 对类行为的某些角度进行评价与解释 注解通过反射获取注解的创建12public @interface TestAnnotation&#123;&#125; 注解的使用123@TestAnnotationpublic class Test&#123;&#125; 元注解可以注解到其他注解上的注解，也就是基本注解，可以用来规范注解的一些行为 @Retention –&gt; 注解的存活周期 RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 @Documented –&gt; 能将注解保存到Javadoc中 @Target –&gt; 注解应用的地方 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @inherited –&gt; 如果父类使用了此注解，那么子类可以继承此注解 12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; @Repeatable –&gt; Java8新注解，多次应用的注解 1234567891011121314@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default &quot;&quot;;&#125;@Person(role=&quot;artist&quot;)@Person(role=&quot;coder&quot;)@Person(role=&quot;PM&quot;)public class SuperMan&#123;&#125; 容器注解存放注解的容器，本身也是注解。 注解的属性注解的属性也叫做成员变量。 注解只有成员变量，没有方法 以无参的方法来声名 方法名为成员名 返回值为成员类型 类型必须是 8 种基本数据类型 类 接口 注解 以上各类型的数组123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg();&#125; 在使用注解的时候，应该为该注解的属性赋值：123@TestAnnotation(id=3,msg=&quot;hello annotation&quot;)public class Test &#123;&#125; 注解中属性可以有默认值，默认值需要用 default 关键值指定：123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; public int id() default -1; public String msg() default &quot;Hi&quot;;&#125; 因此在使用的时候无需再赋初值：12@TestAnnotation()public class Test &#123;&#125; 如果注解中属性名为value，那么可以省略属性名直接赋值使用123456public @interface Check &#123; String value();&#125;@Check(&quot;hi&quot;)int a; 内置注解 @Deprecated @Override @SuppressWarnings @FunctionalInterface Java8新特性，函数式接口可以很容易转化为Lamda表达式。注解与反射 首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解： 1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;&#125; 然后通过 getAnnotation() 方法来获取 Annotation 对象： 1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125; 或者是 getAnnotations() 方法： 1public Annotation[] getAnnotations() &#123;&#125; 如果获取到的Annotation不为null，则可以调用它的属性方法了： 123456789101112131415@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println(&quot;id:&quot;+testAnnotation.id()); System.out.println(&quot;msg:&quot;+testAnnotation.msg()); &#125; &#125;&#125; 程序运行结果：12id:-1msg: 注解的作用 注解本身对程序运行没有直接关系 注解的存在主要是为编译器或APT(Annotation Processing Tool)使用，而要使用的话需要开发者手动调用方法来提取并处理Annotation的信息总结 注解的作用是取决于你想要它做什么","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/tags/Java/"}]},{"title":"Git远程通信详解","slug":"Git远程通信详解","date":"2013-11-23T12:47:23.000Z","updated":"2019-02-14T03:48:44.142Z","comments":true,"path":"DevelopmentTools/Git远程通信详解/","link":"","permalink":"https://blog.mmzsblog.cn/DevelopmentTools/Git远程通信详解/","excerpt":"","text":"说Git是一个分布式的系统，既然它是一个分布式的系统那就肯定会涉及到远程通信，那么Git是采用什么协议来进行远程通信呢？ Local（本地协议）Local本地协议就是基于本地文件系统进行的共享。 比如说公司的一个服务器，在服务器上拿出一个文件夹进行共享，那我们就可以把源码存储在这个共享文件夹里面，那么开发人员就可以基于这个本地协议直接访问这个共享文件夹来实现这个文件的commit和checket。 如下图所示： 优点：简单，直接并且使用了现有的文件权限和网络访问权限。如果是小团队或者小项目建立一个这样的版本管理系统就很轻松。 缺点：这种协议本身受制于文件系统共享的局限性，只能在局域网访问并且速度比较慢。 ssh协议git支持利用ssh协议进行通信，这是绝大部分的Linux系统和Unix系统都支持的，所以利用该协议搭建Git服务是非常方便的。 优点： SSH架构相对于比较简单，通过ssh访问比较安全，在进行文件传输的时候会进行压缩，传输效率会高一些。 缺点： 使用ssh必须将用户ip，服务器的用户名、密码、账号给开发人员，权限体系不灵活。 httpGit的http协议实现是依赖WEB容器（apache、nginx）及cgi组件进行通信交互，并且利用WEB容器本身的一个权限体系进行授权验证。http Dump协议，在Git1.6.6版本之前该协议是只能下载不能提交的，也就是说这种协议值提供只读账号。再Git1.6.6版本之后提供了git-http-backend的CGI用于实现接收远程推送功能。 优点：解决了local和ssh权限验证单一的问题、可基于http url提供匿名服务，从而可以放到公网上去。而local与ssh是很难做到这一点的。 缺点：架设复杂，需要部署一些WEB服务器，和https证书之类的配置。 应用场景：大型团队，需要对权限进行精准控制，需要把服务部署到公网上去。 Git协议 Git协议是包含在Git软件中的一种特殊的守护进程。它监听在一个特定的端口（9418），类似于SSH服务，但是访问不需要任何授权。 优点：传输速度快，是这四个协议里面最快的。如果你的项目很大并且不需要为写进行用户授权，架设Git守护进程是一个很不错的选择。它还使用了SSH相同的数据传输机制，但是它省去了加密和授权的开销。 缺点：Git协议缺乏授权机制并且9418端口不是一个标准端口，防火墙一般不会开放。","categories":[{"name":"DevelopmentTools","slug":"DevelopmentTools","permalink":"https://blog.mmzsblog.cn/categories/DevelopmentTools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.mmzsblog.cn/tags/git/"}]},{"title":"安全控制框架ApacheShiro","slug":"安全控制框架ApacheShiro","date":"2012-11-27T08:30:23.000Z","updated":"2019-02-13T06:40:51.489Z","comments":true,"path":"Java/安全控制框架ApacheShiro/","link":"","permalink":"https://blog.mmzsblog.cn/Java/安全控制框架ApacheShiro/","excerpt":"","text":"[TOC] 什么是Shiro？ 它是一款轻量级的Java安全框架 提供以下服务： Authentication（认证） Authorization（授权） Session Management（会话管理）：并不是我们熟知的HTTP Session，而是一个独立的Session管理框架，不管是否为Web应用，都可以用这套框架。 Cryptography（加密）：封装了许多密码学算法。 Hello ShiroMaven依赖123456789101112&lt;!-- SLF4J --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- apache shiro --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 提供log4j.properties12345log4j.rootLogger = INFO, consolelog4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%-5p %c(%L) - %M%N 以上配置将日志输出到控制台，并配置日志输出格式。 提供一个shiro.ini12[users]shiro = 201314 表示用户名为shiro,密码为201314。 main方法1234567891011121314151617181920212223242526272829package com.laowang.shiro;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloShiro &#123; private static final Logger LOGGER = LoggerFactory.getLogger(HelloShiro.class); public static void main(String[] args) &#123; IniSecurityManagerFactory factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;shiro&quot;, &quot;201314&quot;); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; LOGGER.info(&quot;登录失败！&quot;); return; &#125; LOGGER.info(&quot;登录成功，Hello,&quot; + subject.getPrincipal()); &#125;&#125; 分析此Demo 需要读取classpath下的shiro.ini配置文件，并通过工厂类创建SecurityManager对象，最终将其放入SecurityUtils中，供Shiro框架随时获取。 通过SecurityUtils获取Subject对象，其实就是当前用户，只不过被Shiro称为主体（Subject）。 然后使用Username与Password来创建一个UseramePasswordToken对象，然后通过调用Sbuject对象的login方法并传入token对象，让Shiro进行用户身份验认证。 最后可以通过subject的logout方法来注销本次Session。在Web开发中使用Shiro直接使用官方提供的Web模块123456&lt;!-- shiro web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 在web.xml中添加一个Listener和一个Filter12345678910111213141516&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;listener&gt; &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 其实就是使用EnvironmentLoaderListener来初始化SecurityManager，并通过ShiroFilter来完成认证和授权。 5个表及结构 SQL语句 1234567891011121314151617181920212223242526272829303132333435363738CREATE TABLE USER (id INT NOT NULL AUTO_INCREMENT,user_name VARCHAR(255),PASSWORD VARCHAR(255),PRIMARY KEY (`id`))CREATE TABLE role (id INT NOT NULL AUTO_INCREMENT,role_name VARCHAR(255),PRIMARY KEY (`id`))CREATE TABLE permission (id INT NOT NULL AUTO_INCREMENT,permission_name VARCHAR(255),PRIMARY KEY (`id`))CREATE TABLE user_role (id INT NOT NULL AUTO_INCREMENT,user_id INT,role_id INT,PRIMARY KEY (`id`),FOREIGN KEY (`user_id`) REFERENCES `shiro`.`user`(`id`),FOREIGN KEY (`role_id`) REFERENCES `shiro`.`role`(`id`))CREATE TABLE role_permission (id INT NOT NULL AUTO_INCREMENT,role_id INT,permission_id INT,PRIMARY KEY (`id`),FOREIGN KEY (`role_id`) REFERENCES `shiro`.`role`(`id`),FOREIGN KEY (`permission_id`) REFERENCES `shiro`.`permission`(`id`)) 表结构 在shiro.ini做如下配置通过Shiro的JdbcRealm来进行认证和授权： 1234567891011121314151617181920[main]authc.loginUrl=/loginds=org.apache.commons.dbcp.BasicDataSourceds.driverClassName=com.mysql.jdbc.Driverds.url=jdbc:mysql://localhost:3306/shirods.username=workds.password=123456789jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmjdbcRealm.datasorce=$dsjdbcRealm.authenticationQuery=select password from user where username = ?jdbcRealm.userRolesQuery=select r.role_name from user u,user_role ur,role r where u.id=ur.user_id and r.id=ur.role_id and u.username=?jdbcRealm.permissionsQuery=select p.permission_name from role r,role_permission rp,permission p where r.id=rp.role_id and p.id=rp.permission_id and r.role_name =?jdbcRealm.permissionsLookupEnabled=truesecurityManager.realms=$jdbcRealm[urls]/=anon/space/**=authc 分析以上配置 在[main]片段中，定义了一个authc.loginUrl=/login，表示要跳转的Url地址，映射后可以得到相应的login页面。 然后定义了一个DBCP的Datasource，用于获取JDBC数据库连接。 接着，定义JdbcRealm并指定Datasource，通过以下几条SQL来完成认证和授权。 authenticationQuery：提供身份验证。 userRolesQuery：授权验证，即查询某个用户的角色。 permisisonsQuery：权限验证，即查询某个角色拥有的权限。 最后在[urls]片段中，定义了一些Url过滤规则，shiro已经提供了一些默认的过滤器，我们也可以自定义扩展自己的过滤器。 /=anon：对于“/”请求（根目录）可以匿名访问。 /space/**=authc：对于“/space/”开头的请求，均由authc过滤器完成。 （一个*表示一层目录，两个**表示多层目录）默认过滤器过滤器名称 |功能| 配置项（及其默认值）—|—|—anon|确保只有未登录（匿名）的用户发送的请求才能通过|-authc|确保只有已认证的用户发送的请求才能通过（若未认证则跳转到登录页面）|authc.loginUrl=/login.jspauthc.successUrl=/authc.usernameParam=usernameauthc.passwordParam=passwordauthc.rememberMeParam=rememberMeauthc.failureKeyAttribute=shiroLoginFailureauthcBasic|提供BasicHTTP认证功能（在浏览器中弹出一个登录对话框）|authc.Basic.applicationName=applicationlogout接收结束会话请求|logout.redirectUrl=/noSessionCreation|提供No Sesison解决方案（若有Session就会报错）|-perms|确保只有通过特定权限的用户发送的请求才能通过|-port|确定只有特定端口的请求才能通过|port=80rest|提供Rest解决方案（根据Rest Url计算权限字符串）|-roles|确保只有拥有特定角色的用户发送的请求才能通过|-ssl|确保只有HTTPS的请求才能通过|-user|确保只有已登录的用户发送的请求才能通过（包括已认证或已记住）|-Shiro注解注解|功能—|—RequiresGuest|确保被注解的方法可以被匿名用户访问RequiresUser|确保被注解的方法只能被已登录的用户访问（包括已认证或已记住）RequiresAuthentication|确保被注解的方法只能被已认证的用户访问（不包括已记住）RequiresRoles|确保被注解的方法仅被指定用户访问RequiresPermissions|确保被注解的方法仅被指定权限的用户访问Shiro缓存1234[main]...cacheManager=org.apache.shiro.cache.MemoryConstrainedCacheManagersecurityManager.cacheManager=$cacheManager 在[main]片段中加入以上部分，就可以使用Shiro缓存。此时Shiro会在内存中会用一个Map来缓存查询结果，从而减少数据库的交互次数。Shiro也提供了EhCache扩展。 Shiro加密1234[main]...passwordMatcher=org.apache.shiro.authc.credential.PasswordMatcherjdbcRealm.credentialsMatcher=$passwordMatcher 数据库密码加密12PasswordService passwordService = new DefaultPasswordService();String encryptPassword = passwordService.encryptPassword(plaintextPassword);","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mmzsblog.cn/tags/Java/"}]},{"title":"精炼23种设计模式","slug":"designPatterns","date":"2011-10-24T02:24:00.000Z","updated":"2019-02-14T03:48:27.737Z","comments":true,"path":"DesignPatterns/designPatterns/","link":"","permalink":"https://blog.mmzsblog.cn/DesignPatterns/designPatterns/","excerpt":"","text":"[toc] 一、创建型 工厂模式简单工厂模式以继承的思想分别生产不同的产品。例：123456789101112131415161718192021222324252627282930public interface CPU()&#123; void createCPU();&#125;public class IntelCPU implements CPU&#123; @Override public void createCPU()&#123; //具体实现 &#125;&#125;public class AMDCPU implements CPU&#123; @Override public void createCPU()&#123; //具体实现 &#125;&#125;//工厂public class CPUFactory&#123; public void createCPU(int cpuType)&#123; CPU cpu = null; if(cpuType == 1 )&#123; cpu = new IntelCPU(); //生产IntelCPU，实现细节略。 &#125;else if(cpuType == 2 )&#123; cpu = new AMDCPU(); //生产AMD CPU ，实现细节略。 &#125;else&#123; return null; &#125; &#125;&#125; 抽象工厂模式以继承+归类的思想分别生产不同的产品。例：12345678910111213141516171819202122232425public interface Factory&#123; CPU createCPU(); MainBoard createMainBoard();&#125;public class IntelFactory implements Factory&#123; @Override public CPU createCPU()&#123; return new IntelCPU(); &#125; @Override public MainBoard createCPU()&#123; return new IntelMainBoard(); &#125;&#125;public class AMDFactory implements Factory&#123; @Override public CPU createCPU()&#123; return new AMDCPU(); &#125; @Override public MainBoard createCPU()&#123; return new AMDMainBoard(); &#125;&#125; 工厂方法模式在抽象工厂模式的基础上，更加复杂化子类，让子类再归类，然后再生产不同的产品。例：将文件导出为指定形式（html和pdf，但是还要配合具体的部门，比如标准的输出、财务的输出等），如何设计？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public interface ExportFactory&#123; ExportFile factorty(String type); &#125;&#125;public class ExportHtmlFactory implements Factory&#123; @Override public ExportFile factorty(String type)&#123; if(&quot;standard&quot;.equals(type))&#123; return new ExportStandardHtmlFile(); &#125;else if(&quot;financial&quot;.equals(type))&#123; return new ExportFinancialHtmlFile(); &#125;else&#123; throw new Exception(&quot;未找到&quot;); &#125; &#125;&#125;public class ExportPDFFactory implements Factory&#123; @Override public ExportFile factorty(String type)&#123; if(&quot;standard&quot;.equals(type))&#123; return new ExportStandardPDFFile(); &#125;else if(&quot;financial&quot;.equals(type))&#123; return new ExportFinancialPDFFile(); &#125;else&#123; throw new Exception(&quot;未找到&quot;); &#125; &#125;&#125;public interface ExportFile&#123; public boolean export(String data);&#125; public class ExportStandardHtmlFile implements ExportFile&#123; @Override public boolean export(String data)&#123; //业务逻辑 System.out.println(&quot;标准的HMTL输出&quot;); return true; &#125;&#125;public class ExportFinancialHtmlFile implements ExportFile&#123; @Override public boolean export(String data)&#123; //业务逻辑 System.out.println(&quot;财务的HMTL输出&quot;); return true; &#125;&#125;public class ExportStandardPDFFile implements ExportFile&#123; @Override public boolean export(String data)&#123; //业务逻辑 System.out.println(&quot;标准的PDF输出&quot;); return true; &#125;&#125;public class ExportFinancialPDFFile implements ExportFile&#123; @Override public boolean export(String data)&#123; //业务逻辑 System.out.println(&quot;财务的PDF输出&quot;); return true; &#125;&#125;//客户端public class Client &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub String data = &quot;&quot;; ExportFactory exportFactory = new ExportHtmlFactory(); ExportFile ef = exportFactory.factory(&quot;financial&quot;); ef.export(data); &#125;&#125; 建造者模式建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分离，从而可以生成具有不同的内部表象的产品。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//产品public class Product()&#123; private String part1; private Strign part2; //省略set/get&#125;//抽象建造者public interface Builder&#123; void buildPart1(); void buildPart2(); Product retrieveResult();&#125;public class concreteBuilder implements Builder&#123; private Product product = new Product(); @Override public void buildPart1()&#123; //生产第一部分 &#125; public void buildPart2()&#123; //生产第二部分 &#125; public void retrieveResult()&#123; return product; &#125;&#125;public class Director &#123; private Builder builder; public Director(Builder builder)&#123; this.builder = builder; &#125; public void construct()&#123; this.builder.buildPart1(); this.builder.buildPart2(); &#125;&#125;//客户端public class Client &#123; public static void main(String[]args)&#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.retrieveResult(); System.out.println(product.getPart1()); System.out.println(product.getPart2()); &#125;&#125; 原型模式给出一个原型对象来指明所创建的对象的类型，然后复制这个原型对象创建出更多同类型的对象。|- 克隆：克隆的对象和原对象不是同一个对象，但是类型与原对象类型相同。&nbsp;&nbsp;&nbsp;&nbsp;|- 浅克隆： 所有的对其他对象的引用都仍然指向原来的对象，Object类的clone()方法默认是浅克隆。&nbsp;&nbsp;&nbsp;&nbsp; |- 深度克隆：除了浅度克隆所要克隆的东西外，还要复制原对象所引用的对象。通常让对象实现Serializable接口，然后写入流（序列化），然后读出来（反序列化）。例：12345678910public Object deepClone() throws Exception&#123; //序列化，将对象写到流里 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); //反序列化，从流里读出来 ByteArrayInputStream bis = new ByteArrayInputStream(); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject();&#125; 例：12345678910111213141516171819202122232425262728//抽象原型角色public interface Prototype&#123; //克隆自身的方法 public Object clone();&#125;//具体原型角色public class ConcretePrototype1 implements Prototype&#123; public Prototype clone()&#123; Prototype prototype = new ConcretePrototype1(); return prototype; &#125;&#125;public class ConcretePrototype2 implements Prototype&#123; public Prototype clone()&#123; Prototype prototype = new ConcretePrototype2(); return prototype; &#125;&#125;//客户端public class Client &#123; private Prototype prototype; pulic Client(Prototype prototype)&#123; this.prototype = prototype; &#125; public void operation(Prototype example)&#123; Prototype copy = prototype.clone(); &#125;&#125; 单例模式确保某一个类只有一个实例，单例类需要想全局提供该类的实例。|- 创建一个静态的私有单例类的实例。|- 构造方法私有化，避免外界直接new该单例类。|- 提供一个供外界访问的静态方法。 懒汉模式需要的时候再new对象。1234567private static Singleton instance = null;public static synchronized Singleton getInstance()&#123; if(object == null)&#123; instance = new xxx(); &#125; return instance;&#125; 饿汉模式先new对象，等到需要再使用。1234private static Singleton instance =new xxx();public static Singleton getInstance()&#123; return instance;&#125; 双重检查加锁|- 第一重检查：不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后先检查实例是否存在，如果不存在再进入下面的同步块。|- 第二重检查：进入同步块后，再次检查实例是否存在，如果不存在，就在同步情况下创建一个实例。1234567891011121314private volatile static Singleton instance = null;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; //先检查实例是否存在 if(instance == null)&#123; //同步块，线程安全的创建实例 synchronized(Singleton.class)&#123; //再次检查实例是否存在 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125;&#125; Lazy initialization holder class模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。|- 类级内部类：由static 修饰的内部类。|- 多线程缺省同步锁的知识：在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。如： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- 静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时 &nbsp;&nbsp;&nbsp;&nbsp; |- 访问final字段时 &nbsp;&nbsp;&nbsp;&nbsp; |- 在创建线程之前创建对象时 &nbsp;&nbsp;&nbsp;&nbsp; |- 线程可以看见它将要处理的对象时例：1234567891011121314151617public class Singleton &#123; private Singleton()&#123;&#125; /** * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例 * 没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。 */ private static class SingletonHolder&#123; /** * 静态初始化器，由JVM来保证线程安全 */ private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; |- 枚举实现单例：1234567891011121314public enum Singleton &#123; /** * 定义一个枚举的元素，它就代表了Singleton的一个实例。 */ uniqueInstance; /** * 单例可以有自己的操作 */ public void singletonOperation()&#123; //功能处理 &#125;&#125; 二、结构型适配器模式把一个接口转换成另一种接口从而能够匹配成客户端需要的接口。 类适配器模式把适配类的API转换成目标类的API。例：12345678910111213public interface Target&#123; public void method1(); public void method2();&#125;public class Adaptee&#123; public void method2();&#125;public class Adapter extends Adaptee implements Target&#123; @Override public void method1()&#123; //实际代码 &#125;&#125; 对象适配器模式对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。例：1234567891011121314...//如上的Target和Adapteepublic class Adapter&#123; private Adaptee adaptee; public Adapter(Adaptee adaptee)&#123; this.adaptee = adaptee; &#125; public void method1()&#123; //实际代码 &#125; public void method2()&#123; this.adaptee.method2(); &#125;&#125; 装饰者模式Wrapper模式，以对客户端透明的方式扩展对象的功能，是继承关系的一种替代。|- 装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。|- 允许装饰模式改变接口，增加新的方法。 透明装饰模式透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。 半透明装饰模式装饰角色的接口与抽象构件角色接口不一致。 例：Java中的I/O设计模式，就是典型的装饰模式。 |- InputStream&nbsp;&nbsp;&nbsp;&nbsp;|- ByteArrayInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- FileInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- FilterInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- BufferedInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- DataInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- LineNumberInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- PushbackInputStream //典型的半透明装饰模式，因为它扩展了一个unread()方法，这个方法是抽象接口所没有的。 &nbsp;&nbsp;&nbsp;&nbsp; |- ObjectInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- PipedInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- SquenceInputStream &nbsp;&nbsp;&nbsp;&nbsp; |- StringBufferInputStream 适配器模式（做对比）半透明装饰模式是介于透明装饰模式和适配器模式之间的一种设计模式。例：123456789101112131415161718192021222324252627282930313233343536373839404142434445//抽象构件角色public interface Component&#123; public void sampleOperation();&#125;//具体构件角色public class concreteComponent implements Component&#123; @Override public void sampleOperation()&#123; //具体业务 &#125;&#125;//装饰角色public class Decorator implements Component&#123; private Component component; public Decorator(Component component)&#123; this.component = component; &#125; @Override public void sampleOperation()&#123; //委派给构件 component.sampleOperation(); &#125;&#125;//具体装饰角色public class ConcreteDecoratorA extends Decorator&#123; public ConcreteDecoratorA(Component component)&#123; super(component); &#125; @Override public void sampleOperation()&#123; super.sampleOperation(); //相关业务代码 &#125;&#125;public class ConcreteDecoratorB extends Decorator&#123; public ConcreteDecoratorB(Component component)&#123; super(component); &#125; @Override public void sampleOperation()&#123; super.sampleOperation(); //相关业务代码 &#125;&#125; 桥接模式将抽象部分与它的实现部分分离，使他们都可以独立变化，目的是提高系统的可扩展性。情景：将n种颜色涂在n种形状里，如何设计？|- 提供两个父类一个是颜色、一个形状，颜色父类和形状父类两个类都包含了相应的子类，然后根据需要对颜色和形状进行组合。例：12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Shape &#123; Color color; public void setColor(Color color)&#123; this.color = color; &#125; public abstract void draw();&#125;public interface Color &#123; void bepaint(String shape);&#125;public class black implements Color &#123; @Override public void bepaint(String shape) &#123; System.out.println(&quot;黑色 --&gt;&quot; + shape); &#125;&#125;public class White implements Color &#123; @Override public void bepaint(String shape) &#123; System.out.println(&quot;白色 --&gt;&quot; + shape); &#125;&#125;public class Circle extends Shape&#123; @Override public void draw() &#123; color.bepaint(&quot;圆形&quot;); &#125;&#125;public class Rectangle extends Shape&#123; @Override public void draw() &#123; color.bepaint(&quot;长方形&quot;); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Color white = new White(); Shape rectangle = new Rectangle(); rectangle.setColor(white); rectangle.draw(); &#125;&#125; 结果：白色 –&gt;长方形 组合模式以树的结构来描述部分与整体的概念，和文件系统类似，父文件夹、文件、子文件、子文件夹等等。 安全式要求管理聚集的地方只出现树枝构件中，而不出现在树叶构件中。例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//抽象构件角色public interface Component&#123; //输出组件自身的名称 public void printStruct(String preStr);&#125;//树枝构件public class Composite implements Component&#123; //存储包含的子组件 private List&lt;Component&gt; childComponents = new ArrayList&lt;&gt;(); //组合对象的名字 private String name; public Composite(String name)&#123; this.name = name; &#125; //增加一个子构件 public void addChild(Component child)&#123; childComponents.add(child); &#125; //删除一个子构件 public void removeChild(int index)&#123; childComponents.remove(index); &#125; public List&lt;Component&gt; getChilds()&#123; return childComponents; &#125; //打印 @Override public void printStruct(String preStr)&#123; System.out.println(preStr + &quot;+&quot; + this.name); if(this.childComponents!=null)&#123; preStr = &quot; &quot;; for(Component c : childComponents)&#123; c.printStruct(preStr); &#125; &#125; &#125;&#125;//树叶构件public class Leaf implements Component&#123; private String name; public Leaf(String name)&#123; this.name = name; &#125; @Override public void printStruct(String preStr)&#123; System.out.println(preStr + &quot;-&quot; + name); &#125;&#125;//客户端public class Client&#123; public static void main(String[] args)&#123; Composite root = new Composite(&quot;服装&quot;); Composite c1 = new Composite(&quot;男装&quot;); Composite c2 = new Composite(&quot;女装&quot;); Leaf leaf1 = new Leaf(&quot;衬衫&quot;); Leaf leaf2 = new Leaf(&quot;夹克&quot;); Leaf leaf3 = new Leaf(&quot;裙子&quot;); Leaf leaf4 = new Leaf(&quot;套装&quot;); root.addChild(c1); root.addChild(c2); c1.addChild(leaf1); c1.addChild(leaf2); c2.addChild(leaf3); c2.addChild(leaf4); root.printStruct(&quot;&quot;); &#125;&#125; 透明式透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。例：123456789101112131415161718192021222324252627282930313233343536373839public abstract class Component &#123; /** * 输出组建自身的名称 */ public abstract void printStruct(String preStr); /** * 聚集管理方法，增加一个子构件对象 * @param child 子构件对象 */ public void addChild(Component child)&#123; /** * 缺省实现，抛出异常，因为叶子对象没有此功能 * 或者子组件没有实现这个功能 */ throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); &#125; /** * 聚集管理方法，删除一个子构件对象 * @param index 子构件对象的下标 */ public void removeChild(int index)&#123; /** * 缺省实现，抛出异常，因为叶子对象没有此功能 * 或者子组件没有实现这个功能 */ throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); &#125; /** * 聚集管理方法，返回所有子构件对象 */ public List&lt;Component&gt; getChild()&#123; /** * 缺省实现，抛出异常，因为叶子对象没有此功能 * 或者子组件没有实现这个功能 */ throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); &#125;&#125; Composite和Leaf与上面一样，不一样的是Client端，Client不需要关心他们之间的关系：12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; Component root = new Composite(&quot;服装&quot;); Component c1 = new Composite(&quot;男装&quot;); Component c2 = new Composite(&quot;女装&quot;); Component l1 = new Leaf(&quot;衬衫&quot;); Component l2 = new Leaf(&quot;长袖&quot;); Component l3 = new Leaf(&quot;毛衣&quot;); Component l4 = new Leaf(&quot;貂皮&quot;); root.addChild(c1); root.addChild(c2); root.addChild(l1); root.addChild(l2); root.addChild(l3); root.addChild(l4); root.printStruct(&quot;&quot;); &#125;&#125; 外观模式(Facade)外观模式主要是将客户端直接与多个模块打交道的方式改为客户端与门面打交道，然后门面再去与各个模块打交道。客户可以不知道各个模块的具体实现甚至可以不用知道模块是否存在。例：12345678910111213141516171819202122232425public class ModualA&#123; public void test();&#125;public class ModualB&#123; public void test();&#125;public class ModualC&#123; public void test();&#125;public class Facade&#123; public void test()&#123; ModualA a = new ModualA(); a.test(); ModualB b = new ModualB(); b.test(); ModualC c = new ModualC(); c.test(); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Facade facade = new Facade(); facade.test(); &#125;&#125; |- Facade模式还可以用在子系统的某些功能不需要暴露给其他子系统的情况，如下：例：123456789101112131415161718192021222324252627282930public class ModualA&#123; //暴露给其他子系统的方法 public void test1()&#123; &#125; //不暴露给其他子系统的方法 private void test2()&#123; &#125;&#125;public class ModualB&#123; //暴露给其他子系统的方法 public void test1()&#123; &#125; //不暴露给其他子系统的方法 private void test2()&#123; &#125;&#125;public class Facade&#123; ModualA a = new ModualA(); ModualB b = new ModualB(); public void testa()&#123; a.test1(); &#125; public vid testb()&#123; b.test2(); &#125;&#125; 享元模式以共享的方式高效地支持大量的细粒度对象，目的是减少多次利用的对象重复创建对内存造成较大的开销。|- 英文是flyweight，轻量级的。但是根据设计模式中的概念，将此译为享元，意思是共享元数据，相当于共享对象。|- Java中String类型就是使用了享元模式，String对象是final类型的，Java中的字符串常量都是存在常量池中的。例：123String a = &quot;abc&quot;;String b = &quot;abc&quot;;System.out.println(a==b); 结果为：true 单纯享元模式：共享对象共享对象例：123456789101112131415161718192021222324252627282930313233343536373839404142public interface FlyWeight&#123; //具体业务类，这里简写一个 public void operation(Character state);&#125;public class ConcreteFlyWeight implements FlyWeight &#123; private Character intrinsicState = null; public ConcreteFlyWeight (Character state)&#123; this.intrinsicState = state; &#125; public void operation(Character state)&#123; System.out.println(&quot;intrinsicState :&quot; + this.intrinsicState); System.out.println(&quot;extrinsicState :&quot; + state); &#125;&#125;public class FlyWeightFactory&#123; private Map&lt;Character,FlyWeight&gt; files = new HashMap&lt;&gt;(); public FlyWeight factory(Character state)&#123; FlyWeight fly = files.get(state); //判断是否已经有了这个对象 if(fly ==null)&#123; //如果没有，就创建，并且加入到集合中。 fly = new ConcreteFlyWeight(state); files.put(state,fly); &#125; //如果有，直接返回 return fly; &#125;&#125;public class Client&#123; public static void main(String[] args) &#123; FlyWeightFactory factory = new FlyWeightFactory(); FlyWeight fly = factory.factory(new Character(&apos;a&apos;)); System.out.println(fly.hashCode()); fly.operation(&quot;first&quot;); fly = factory.factory(new Character(&apos;b&apos;)); System.out.println(fly.hashCode()); fly.operation(&quot;second&quot;); fly = factory.factory(new Character(&apos;a&apos;)); System.out.println(fly.hashCode()); fly.operation(&quot;third&quot;); &#125;&#125; 结果如下：21685669instrinsicState :aextrinsicState :first19997786instrinsicState :bextrinsicState :second21685669instrinsicState :aextrinsicState :third由此可见，第一次和第三次对象的hashCode一样，说明在内存地址中是同一个对象。 复杂享元模式&nbsp;&nbsp;&nbsp;&nbsp;将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public interface FlyWeight &#123; void operation(String state);&#125;public class ConcreteFlyWeight implements FlyWeight &#123; private Character intrinsicState = null; public ConcreteFlyWeight(Character state) &#123; this.intrinsicState = state; &#125; @Override public void operation(String state) &#123; System.out.println(&quot;instrinsicState :&quot;+ this.intrinsicState); System.out.println(&quot;extrinsicState :&quot;+ state); &#125;&#125;public class CompositeConcreteFlyWeight implements FlyWeight &#123; private Map&lt;Character,FlyWeight&gt; files = new HashMap&lt;&gt;(); public void add(Character key,FlyWeight fly)&#123; files.put(key, fly); &#125; @Override public void operation(String state) &#123; FlyWeight fly = null; for(Object o : files.keySet())&#123; fly = files.get(o); System.out.println(o+&quot;: &quot;+fly.hashCode()); fly.operation(state); &#125; &#125;&#125;public class FlyWeightFactory &#123; private Map&lt;Character,FlyWeight&gt; files = new HashMap&lt;&gt;(); //复合享元工厂方法 public FlyWeight factory(List&lt;Character&gt; compositeStateList)&#123; CompositeConcreteFlyWeight compoisteFlyWeight = new CompositeConcreteFlyWeight(); for(Character state : compositeStateList)&#123; compoisteFlyWeight.add(state,this.factory(state)); &#125; return compoisteFlyWeight; &#125; public FlyWeight factory(Character state) &#123; FlyWeight fly = null; fly = files.get(state); if(fly == null)&#123; fly = new ConcreteFlyWeight(state); files.put(state,fly); &#125; return fly; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; List&lt;Character&gt; compositeState = new ArrayList&lt;&gt;(); compositeState.add(&apos;a&apos;); compositeState.add(&apos;b&apos;); compositeState.add(&apos;c&apos;); compositeState.add(&apos;a&apos;); compositeState.add(&apos;b&apos;); FlyWeightFactory flyWeightFactory = new FlyWeightFactory(); FlyWeight compositeFly1 = flyWeightFactory.factory(compositeState); FlyWeight compositeFly2 = flyWeightFactory.factory(compositeState); compositeFly1.operation(&quot;composite --&gt;&quot;); System.out.println(&quot;+++++++++++++++&quot;); System.out.println(&quot;复合享元是不可以共享：&quot;+(compositeFly1 == compositeFly2)); System.out.println(compositeFly1.hashCode()+&quot;,&quot;+compositeFly2.hashCode()); Character state = &apos;a&apos;; Character state2 = &apos;b&apos;; FlyWeight fly1 = flyWeightFactory.factory(state); FlyWeight fly2 = flyWeightFactory.factory(state); FlyWeight fly3 = flyWeightFactory.factory(state2); System.out.println(&quot;单纯享元是可以共享的：&quot;+(fly1 == fly2)); System.out.println(&quot;fly1: &quot; + fly1.hashCode()+&quot;,state: &quot;+state); System.out.println(&quot;fly2: &quot; + fly2.hashCode()+&quot;,state: &quot;+state); System.out.println(&quot;fly3: &quot; + fly3.hashCode()+&quot;,state: &quot;+state2); &#125;&#125; 运行结果：a: 21685669instrinsicState :aextrinsicState :composite –&gt;b: 19997786instrinsicState :bextrinsicState :composite –&gt;c: 24079912instrinsicState :cextrinsicState :composite –&gt;+++++++++++++++复合享元是不可以共享：false23050916,32379559单纯享元是可以共享的：truefly1: 21685669,state: afly2: 21685669,state: afly3: 19997786,state: b 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用，类似于中介，客户与客户之间无法直接进行交流，需要使用一个媒介。例：123456789101112131415161718public abstract class AbstractObject &#123; public abstract void operation();&#125;public class RealObject extends AbstractObject &#123; @Override public void operation() &#123; System.out.println(&quot;一些操作&quot;); &#125;&#125;public class ProxyObject extends AbstractObject &#123; RealObject realObject = new RealObject(); @Override public void operation() &#123; System.out.println(&quot;before do ----&quot;); realObject.operation(); System.out.println(&quot;after do ----&quot;); &#125;&#125; 三、 行为型责任链模式请求以链式传递，具体哪个类处理客户端不知。Tomcat的Filter处理过程便是责任链模式。|- 抽象处理者：定义接口，并且持有下一个处理类的对象。|- 具体处理者：可以根据条件判断是否处理或者移交给下一个处理类处理。例：12345678910111213141516171819202122232425262728293031323334353637//抽象处理角色public abstract class Handler &#123; //持有的后继责任对象 protected Handler successor; //处理请求的方法 public abstract void handlerRequest(); public Handler getSuccessor() &#123; return successor; &#125; public void setSuccessor(Handler successor) &#123; this.successor = successor; &#125;&#125;//具体处理角色public class ConcreteHandler extends Handler &#123; @Override public void handlerRequest() &#123; if (getSuccessor() != null) &#123; System.out.println(&quot;放过请求&quot;); getSuccessor().handlerRequest(); &#125;else&#123; System.out.println(&quot;处理请求&quot;); &#125; &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; //组装责任链 Handler handler1 = new ConcreteHandler(); Handler handler2 = new ConcreteHandler(); handler1.setSuccessor(handler2); //提交请求 handler1.handlerRequest(); &#125;&#125; 命令模式把发出命令的责任和执行命令的责任分离，委派给不同的对象。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//接收者public class Receiver &#123; public void action()&#123; //真正执行命令的操作 System.out.println(&quot;执行操作&quot;); &#125;&#125;//抽象命令接口public interface Command &#123; //执行方法 void excute();&#125;//具体命令public class ConcreteCommand implements Command &#123; //持有相应的接收者对象 private Receiver receiver = null; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void excute() &#123; receiver.action(); &#125;&#125;//请求者public class Invoker &#123; private Command command= null; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.excute(); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; //创建接收者 Receiver receiver = new Receiver(); //创建命令对象，设置它的接收者 Command command = new ConcreteCommand(receiver); //创建请求者，把命令设置进去 Invoker invoker = new Invoker(command); //执行方法 invoker.action(); &#125;&#125; 注：命令模式使得客户端和具体实现命令的接收者对象完全解耦。 解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。|- 通俗来讲就是定义一些规则，用你自己的方式来实现这些规则，并且调用此规则来完成一些功能。例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 表达式接口 */public interface Expression &#123; boolean interpret(String context);&#125;public class TerminalExpression implements Expression &#123; private String data; public TerminalExpression(String data) &#123; this.data = data; &#125; @Override public boolean interpret(String context) &#123; return context.contains(data); &#125;&#125;/** * 与表达式 */public class AndExpression implements Expression &#123; private Expression expression1 = null; private Expression expression2 = null; public AndExpression(Expression expression1, Expression expression2) &#123; this.expression1 = expression1; this.expression2 = expression2; &#125; @Override public boolean interpret(String context) &#123; return expression1.interpret(context)&amp;&amp; expression2.interpret(context); &#125;&#125;/** * 或表达式 */public class OrExpression implements Expression &#123; private Expression expression1 = null; private Expression expression2 = null; public OrExpression(Expression expression1,Expression expression2) &#123; this.expression1 = expression1; this.expression2 = expression2; &#125; @Override public boolean interpret(String context) &#123; boolean flag1 = expression1.interpret(context); boolean flag2 = expression2.interpret(context); return flag1|| flag2; &#125;&#125;//客户端public class Client &#123; //规则：Robert 和 John 是男性 public static Expression getMaleExpression()&#123; Expression robert = new TerminalExpression(&quot;Robert&quot;); Expression john = new TerminalExpression(&quot;john&quot;); return new OrExpression(robert,john); &#125; //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression()&#123; Expression julie = new TerminalExpression(&quot;Julie&quot;); Expression married = new TerminalExpression(&quot;Married&quot;); return new AndExpression(julie, married); &#125; public static void main(String[] args) &#123; Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;john&quot;)); System.out.println(&quot;Julie is a married women? &quot; + isMarriedWoman.interpret(&quot;Married Julie&quot;)); &#125;&#125; 以上代码运行结果为：John is male? trueJulie is a married women? true 中介者模式为了减少同事类之间的耦合，独立改变他们之间的交互。|- 同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。|- 情景：类A和类B都持有一个数，要保证A中的数字改变的时候B中的数字乘以100，B中的数字改变的时候，A中的数字除以100。例（传统方式）：1234567891011121314151617181920212223242526272829303132333435363738public abstract AbstractColleague&#123; protected int number; public void setNumber(int number)&#123; this.number = number; &#125; public int getNumber()&#123; return number; &#125; public abstract void setNumber(int number,AbstractColleague colleague);&#125;public class ColleagueA extends AbstractColleague&#123; @Override public void setNumber(int number,AbstractColleague colleague)&#123; this.number = number; colleague.setNumber(number * 100); &#125;&#125;public class ColleagueB extends AbstractColleague&#123; @Override public void setNumber(int number,AbstractColleague colleague)&#123; this.number = number; colleague.setNumber(number / 100); &#125;&#125;public class Client()&#123; public static void main(String[] args)&#123; AbstractColleague colleagueA = new ColleagueA(); AbstractColleague colleagueB = new ColleagueB(); colleagueA.setNumber(500,colleagueB); System.out.println(&quot;---------设置A影响B---------&quot;); System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber()); System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber()); colleagueB.setNumber(2500600,colleagueA); System.out.println(&quot;---------设置B影响A---------&quot;); System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber()); System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber()); &#125;&#125; 运行结果：———设置A影响B———collA的值 :500collB的值 :50000———设置B影响A———collA的值 :25006collB的值 :2500600例（中介者模式：让中介类参与其中，避免A和B的直接交互）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 中介者模式 */public abstract class AbstractColleague &#123; protected int number; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; //这里传入的是一个中介类 public abstract void setNumber(int number,AbstractMediator media); public void test()&#123; &#125;&#125;public class ColleagueA extends AbstractColleague &#123; @Override public void setNumber(int number, AbstractMediator mediator) &#123; this.number = number; //让中介类来完成功能 mediator.affectB(); &#125;&#125;public class ColleagueB extends AbstractColleague &#123; @Override public void setNumber(int number, AbstractMediator mediator) &#123; this.number = number; mediator.affectA(); &#125;&#125;public abstract class AbstractMediator &#123; //持有两个实际对象的目的是让他们的状态随着改变。 protected AbstractColleague A; protected AbstractColleague B; //构造方法通常是一种非常好的做法，可以让类的状态一直保持着传递状态。 public AbstractMediator(AbstractColleague a, AbstractColleague b) &#123; A = a; B = b; &#125; public abstract void affectB(); public abstract void affectA();&#125;public class Mediator extends AbstractMediator &#123; public Mediator(AbstractColleague colleagueA,AbstractColleague colleagueB) &#123; super(colleagueA,colleagueB); &#125; @Override public void affectB() &#123; int number = A.getNumber(); B.setNumber(number * 100); &#125; @Override public void affectA() &#123; int number = B.getNumber(); A.setNumber(number / 100); &#125;&#125;//Clientpublic class Client &#123; public static void main(String[] args) &#123; AbstractColleague colleagueA = new ColleagueA(); AbstractColleague colleagueB = new ColleagueB(); AbstractMediator mediator = new Mediator(colleagueA,colleagueB); colleagueA.setNumber(500,mediator); System.out.println(&quot;---------设置A影响B---------&quot;); System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber()); System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber()); colleagueB.setNumber(2500600,mediator); System.out.println(&quot;---------设置B影响A---------&quot;); System.out.println(&quot;collA的值 :&quot;+colleagueA.getNumber()); System.out.println(&quot;collB的值 :&quot;+colleagueB.getNumber()); &#125;&#125; 运行结果如下：———设置A影响B———collA的值 :500collB的值 :50000———设置B影响A———collA的值 :25006collB的值 :2500600注：一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。&nbsp;&nbsp;|- 网状结构：类与类之间是多对多的关系，牵一发而动全身。&nbsp;&nbsp;|- 星状结构：各类都与中介类单独联系，不与其他的类牵连。 迭代模式（Cursor）可以顺序地访问一个聚集中的元素而不暴露聚集的内部表象（internal representation）。|- Java中的集合框架很多都使用的迭代模式的聚集，如Vector、ArrayList、HashSet、HashMap、Hashtable等。例：123456/** * 抽象聚集角色类 */public abstract class Aggregate &#123; public abstract Iterator createInterator();&#125; /** 具体聚集角色类: 实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。*/1234567891011121314151617181920212223public class ConcreteAggregate extends Aggregate &#123; private Object[] objArray = null; public ConcreteAggregate(Object[] objArray) &#123; this.objArray = objArray; &#125; @Override public Iterator createInterator() &#123; return new ConcreteIterator(this); &#125; public Object getElement(int index)&#123; if(index &lt;objArray.length)&#123; return objArray[index]; &#125; else&#123; return null; &#125; &#125; public int size()&#123; return objArray.length; &#125;&#125; /** 抽象迭代子角色类*/12345678910public interface Iterator &#123; //move to first void first(); //move to last void next(); boolean isLast(); Object currentItem();&#125; /** 具体迭代子角色*/123456789101112131415161718192021222324252627282930313233public class ConcreteIterator implements Iterator &#123; private ConcreteAggregate agg; private int index = 0; private int size = 0; public ConcreteIterator(ConcreteAggregate agg) &#123; this.agg = agg; this.index = 0; this.size = agg.size(); &#125; @Override public void first() &#123; index = 0; &#125; @Override public void next() &#123; if(index &lt; size)&#123; index ++; &#125; &#125; @Override public boolean isLast() &#123; return (index &gt;= size); &#125; @Override public Object currentItem() &#123; return agg.getElement(index); &#125;&#125; //客户端123456789101112131415public class Client &#123; public void operation()&#123; Object[] objArray = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;&#125;; Aggregate agg = new ConcreteAggregate(objArray); Iterator iter = agg.createInterator(); while (!iter.isLast())&#123; System.out.println(iter.currentItem()); iter.next(); &#125; &#125; public static void main(String[] args) &#123; Client client = new Client(); client.operation(); &#125;&#125; 观察者模式观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。例：/** 抽象主题角色类：把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。 抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。*/1234567891011121314151617181920212223242526272829303132public class Subject &#123; /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer)&#123; list.add(observer); System.out.println(&quot;Attached an observer&quot;); &#125; /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer)&#123; list.remove(observer); &#125; /** * 通知所有注册的观察者对象 */ public void nodifyObservers(String newState)&#123; for(Observer observer : list)&#123; observer.update(newState); &#125; &#125;&#125; /** 具体角色类：将有关状态存入具体观察者对象； 在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。*/1234567891011121314public class ConcreteSubject extends Subject &#123; private String state; public String getState() &#123; return state; &#125; public void change(String newState)&#123; state = newState; System.out.println(&quot;主题状态为：&quot; + state); //状态发生改变，通知各个观察者 this.nodifyObservers(state); &#125;&#125; /** 抽象观察者角色类：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。*/1234public interface Observer &#123; //更新方法 void update(String state);&#125; /** 具体观察者角色类：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态协调。 如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。*/12345678910111213public class ConcreteObserver implements Observer&#123; //观察者的状态 private String observerState; @Override public void update(String state) &#123; /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = state; System.out.println(&quot;状态为：&quot;+observerState); &#125;&#125; //客户端123456789101112public class Client &#123; public static void main(String[] args) &#123; //创建主题对象 ConcreteSubject subject = new ConcreteSubject(); //创建观察者对象 Observer observer = new ConcreteObserver(); //将观察者对象登记到主题对象上 subject.attach(observer); //改变主题对象的状态 subject.change(&quot;new state&quot;); &#125;&#125; 运行结果如下：Attached an observer主题状态为：new state状态为：new state 策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。|- 对算法的包装。|- 简而言之：准备一组算法，并将每一个算法封装起来，使得它们可以互换。例（思路模板）：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 抽象策略类 */public interface Strategy &#123; //策略方法 void strategyInterface();&#125;/** * 环境角色类 */public class Context &#123; //持有一个具体策略的对象 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * @param strategy 具体策略对象 */ public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; /** * 策略方法 */ public void contextInterface()&#123; strategy.strategyInterface(); &#125;&#125;/** * 具体策略类 */public class ConcreteStrategyA implements Strategy &#123; @Override public void strategyInterface() &#123; //业务代码 &#125;&#125;/** * 具体策略类 */public class ConcreteStrategyB implements Strategy &#123; @Override public void strategyInterface() &#123; //业务代码 &#125;&#125; 例（具体事例：图书打折问题，初级会员没有折扣，中级会员9折，高级会员8折）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 抽象折扣类 */public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ double calcPrice(double booksPrice);&#125;/** * 初级会员 */public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println(&quot;对于初级会员的没有折扣&quot;); return booksPrice; &#125;&#125;/** * 中级会员9折 */public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println(&quot;中级会员9折&quot;); return booksPrice * 0.9; &#125;&#125;/** * 高级会员8折 */public class AdvancedMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println(&quot;高级会员8折&quot;); return booksPrice * 0.8; &#125;&#125;public class Price &#123; private MemberStrategy strategy; public Price(MemberStrategy strategy) &#123; this.strategy = strategy; &#125; //计算书价 public double quote(double booksPrice)&#123; return this.strategy.calcPrice(booksPrice); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; MemberStrategy memberStrategy = new AdvancedMemberStrategy(); Price price = new Price(memberStrategy); double quote = price.quote(300); System.out.println(&quot;图书最终价格为：&quot;+quote); &#125;&#125; 运行结果如下：高级会员8折图书最终价格为：240.0 模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。|- 不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。|- 模板方法在Servlet中的应用：使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类。&nbsp;&nbsp;&nbsp;&nbsp;|- ttpService类提供了一个service()方法，&nbsp;&nbsp;&nbsp;&nbsp;|- 这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。&nbsp;&nbsp;&nbsp;&nbsp;|- 这些do方法需要由HttpServlet的具体子类提供。因此这是典型的模板方法模式。 |- 关键：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。例：123456789101112131415161718192021222324252627282930public abstract class AbstractTemplate &#123; /** * 模板方法 */ public void templateMethod()&#123; abstractMethod(); hookMethod(); concreteMethod(); &#125; //基本方法（由子类实现） protected abstract void abstractMethod(); //基本方法（空方法） protected void hookMethod()&#123;&#125; //基本方法（已经实现） protected final void concreteMethod()&#123; //业务相关代码 &#125;&#125;public class ConcreteTemplate extends AbstractTemplate &#123; //基本方法实现 @Override protected void abstractMethod() &#123; //业务相关代码 &#125; //重写父类方法 @Override protected void hookMethod() &#123; //业务相关代码 &#125;&#125; 访问者模式封装一些施加于某种数据结构元素之上的操作。|- 分派的概念：根据对象的类型而对方法进行的选择。 静态分派发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。例（墨子骑马的故事作为例子，墨子可以骑白马或者黑马）：123456789101112131415161718192021public class Mozi &#123; public void ride(Horse h)&#123; System.out.println(&quot;骑马&quot;); &#125; public void ride(WhiteHorse wh)&#123; System.out.println(&quot;骑白马&quot;); &#125; public void ride(BlackHorse bh)&#123; System.out.println(&quot;骑黑马&quot;); &#125; public static void main(String[] args) &#123; Horse wh = new WhiteHorse(); Horse bh = new BlackHorse(); Mozi mozi = new Mozi(); mozi.ride(wh); mozi.ride(bh); &#125;&#125; 运行结果如下：骑马骑马注：但是两次对ride()方法的调用传入的是不同的参数，也就是wh和bh。它们虽然具有不同的真实类型，但是它们的静态类型都是一样的，均是Horse类型。|- 由此可见：重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。 动态分派发生在运行时期，动态分派动态地置换掉某个方法。例：1234567891011121314151617public class Horse &#123; public void eat()&#123; System.out.println(&quot;马吃草&quot;); &#125;&#125;public class BlackHorse extends Horse &#123; @Override public void eat() &#123; System.out.println(&quot;黑马吃草&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Horse horse = new BlackHorse(); horse.eat(); &#125;&#125; 运行结果如下：黑马吃草因此，对比可知：问题的核心就是Java编译器在编译时期并不总是知道哪些代码会被执行。|- 编译器仅仅知道对象的静态类型，而不知道对象的真实类型。|- 方法的调用则是根据对象的真实类型，而不是静态类型。这样一来，上面最后一行的eat()方法调用的是BlackHorse类的eat()方法，打印的是“黑马吃草”。 备忘录模式在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。|- 简而言之，复制一份对象的内部状态，保存下来以备不时之需。 白箱备忘录模式备忘录角色对任何对象都提供一个接口（宽接口），备忘录角色的内部所存储的状态就对所有对象公开。例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 发起人角色类 */public class Originator &#123; //持有一个状态标志 private String state; public Memento createMemento()&#123; return new Memento(state); &#125; public void restoreMemento(Memento memento)&#123; this.state = memento.getState(); &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; System.out.println(&quot;当前状态：&quot; + state); &#125;&#125;/** * 备忘录角色类 */public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public void setState(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125;&#125;/** * 负责人角色 */public class CareTaker &#123; private Memento memento; //获取备忘录 public Memento retrieveMemento()&#123; return this.memento; &#125; //设置备忘录 public void saveMemento(Memento memento)&#123; this.memento = memento; &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Originator o = new Originator(); CareTaker care = new CareTaker(); //创建 o.setState(&quot;on&quot;); care.saveMemento(o.createMemento()); //修改 o.setState(&quot;off&quot;); //恢复 o.restoreMemento(care.retrieveMemento()); System.out.println(o.getState()); &#125;&#125; 运行结果如下：当前状态：on当前状态：offon 黑箱备忘录模式备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。|- 在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 发起人角色类 */public class Originator &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; System.out.println(&quot;当前状态 --&gt;&quot; + state); &#125; public MementoIF createMemento()&#123; return new Memento(state); &#125; public void restoreMemento(MementoIF memento)&#123; this.setState(((Memento)memento).getState()); //以内部类的方式，将备忘录角色只为发起人角色提供功能。 private class Memento implements MementoIF&#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; &#125;&#125;/** * 标识接口，窄接口 */public interface MementoIF &#123;&#125;//负责人角色类public class CareTaker &#123; private MementoIF memento; public MementoIF retrieveMemento()&#123; return memento; &#125; public void saveMemento(MementoIF memento)&#123; this.memento = memento; &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Originator o = new Originator(); CareTaker careTak er = new CareTaker(); o.setState(&quot;on&quot;); //此时虽然无法直接访问内部类Menmento，但是通过createMemento()方法可以得到。 careTaker.saveMemento(o.createMemento()); o.setState(&quot;off&quot;); o.restoreMemento(careTaker.retrieveMemento()); &#125;&#125; 运行结果如下：当前状态 –&gt;on当前状态 –&gt;off当前状态 –&gt;on 多重检查点往往系统中部只需要恢复对象的某一个状态，而是要恢复多个状态。例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class Originator &#123; private List&lt;String&gt; states; //检查点指数 private int index; /** * 构造函数 */ public Originator()&#123; states = new ArrayList&lt;String&gt;(); index = 0; &#125; /** * 工厂方法，返还一个新的备忘录对象 */ public Memento createMemento()&#123; return new Memento(states , index); &#125; /** * 将发起人恢复到备忘录对象记录的状态上 */ public void restoreMemento(Memento memento)&#123; states = memento.getStates(); index = memento.getIndex(); &#125; /** * 状态的赋值方法 */ public void setState(String state)&#123; states.add(state); index++; &#125; /** * 辅助方法，打印所有状态 */ public void printStates()&#123; for(String state : states)&#123; System.out.println(state); &#125; &#125;&#125;public class Memento &#123; private List&lt;String&gt; states; private int index; /** * 构造函数 */ public Memento(List&lt;String&gt; states , int index)&#123; this.states = new ArrayList&lt;String&gt;(states); this.index = index; &#125; public List&lt;String&gt; getStates() &#123; return states; &#125; public int getIndex() &#123; return index; &#125;&#125;public class CareTaker &#123; private Originator o; private List&lt;Memento&gt; mementos = new ArrayList&lt;Memento&gt;(); private int current; /** * 构造函数 */ public CareTaker(Originator o)&#123; this.o = o; current = 0; &#125; /** * 创建一个新的检查点 */ public int createMemento()&#123; Memento memento = o.createMemento(); mementos.add(memento); return current++; &#125; /** * 将发起人恢复到某个检查点 */ public void restoreMemento(int index)&#123; Memento memento = mementos.get(index); o.restoreMemento(memento); &#125; /** * 将某个检查点删除 */ public void removeMemento(int index)&#123; mementos.remove(index); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Originator o = new Originator(); CareTaker c = new CareTaker(o); //改变状态 o.setState(&quot;state 0&quot;); //建立一个检查点 c.createMemento(); //改变状态 o.setState(&quot;state 1&quot;); //建立一个检查点 c.createMemento(); //改变状态 o.setState(&quot;state 2&quot;); //建立一个检查点 c.createMemento(); //改变状态 o.setState(&quot;state 3&quot;); //建立一个检查点 c.createMemento(); //打印出所有检查点 o.printStates(); System.out.println(&quot;-----------------恢复检查点-----------------&quot;); //恢复到第二个检查点 c.restoreMemento(2); //打印出所有检查点 o.printStates(); &#125;&#125; 运行结果如下：state 0state 1state 2state 3—————–恢复检查点—————–state 0state 1state 2 状态模式允许一个对象在其内部状态改变的时候改变其行为，这个对象看上去就像是改变了它的类一样。|- 把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。例（思路模型）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//上下文对象public class Context &#123; private State state; public void setState(State state) &#123; this.state = state; &#125; //用户感兴趣的接口方法 public void request(String sampleParam)&#123; state.handle(sampleParam); &#125;&#125;/** * 抽象状态类 */public interface State &#123; //状态对应的处理 void handle(String sampleParam);&#125;public class ConcreteStateA implements State &#123; @Override public void handle(String sampleParam) &#123; System.out.println(&quot;ConcreteStateA handle :&quot;+sampleParam); &#125;&#125;public class ConcreteStateB implements State &#123; @Override public void handle(String sampleParam) &#123; System.out.println(&quot;ConcreteStateB handle :&quot;+sampleParam); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; //创建状态 State stateA = new ConcreteStateA(); State stateB = new ConcreteStateB(); //创建环境 Context context = new Context(); //将状态设置到环境中 context.setState(stateA); //请求 context.request(&quot;test&quot;); context.setState(stateB); //请求 context.request(&quot;test&quot;); &#125;&#125; 运行结果如下：ConcreteStateA handle :testConcreteStateB handle :test例（具体事例：投票事件，分为普通投票、重复投票、恶意刷票、黑名单禁止刷票几种状态）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public interface VoteState &#123; /** * * @param user 投票人 * @param voteItem 投票项目 * @param voteManager 投票上下文，用来传递上下文状态。 */ void vote(String user,String voteItem,VoteManager voteManager);&#125;public class NormalVote implements VoteState &#123; @Override public void vote(String user, String voteItem, VoteManager voteManager) &#123; //正常投票，记录到投票记录中 voteManager.getMapVote().put(user, voteItem); System.out.println(&quot;恭喜投票成功&quot;); &#125;&#125;public class RepeatVoteState implements VoteState &#123; @Override public void vote(String user, String voteItem, VoteManager voteManager) &#123; //重复投票，暂时不做处理 System.out.println(&quot;请不要重复投票&quot;); &#125;&#125;public class SpiteVoteState implements VoteState &#123; @Override public void vote(String user, String voteItem, VoteManager voteManager) &#123; // 恶意投票，取消用户的投票资格，并取消投票记录 String str = voteManager.getMapVote().get(user); if(str != null)&#123; voteManager.getMapVote().remove(user); &#125; System.out.println(&quot;你有恶意刷屏行为，取消投票资格&quot;); &#125;&#125;public class BlackVoteState implements VoteState &#123; @Override public void vote(String user, String voteItem, VoteManager voteManager) &#123; //记录黑名单中，禁止登录系统 System.out.println(&quot;进入黑名单，将禁止登录和使用本系统&quot;); &#125;&#125;public class VoteManager &#123; //持有状态处理对象 private VoteState state = null; //记录用户投票的结果 private Map&lt;String,String&gt; mapVote = new HashMap&lt;&gt;(); //记录用户投票次数 private Map&lt;String,Integer&gt; mapVoteCount = new HashMap&lt;&gt;(); //获取用户投票结果 public Map&lt;String,String&gt; getMapVote()&#123; return mapVote; &#125; public void vote(String user,String voteItem)&#123; Integer oldVoteCount = mapVoteCount.get(user); if(oldVoteCount == null)&#123; oldVoteCount = 0; &#125; oldVoteCount += 1; mapVoteCount.put(user,oldVoteCount); if(oldVoteCount == 1)&#123; state = new NormalVote(); &#125; else if (oldVoteCount &gt; 1 &amp;&amp; oldVoteCount &lt; 5) &#123; state = new RepeatVoteState(); &#125; else if (oldVoteCount &gt;= 5 &amp;&amp; oldVoteCount &lt; 8) &#123; state = new SpiteVoteState(); &#125; else if (oldVoteCount &gt; 8) &#123; state = new BlackVoteState(); &#125; state.vote(user,voteItem,this); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; VoteManager voteManager = new VoteManager(); for(int i = 0;i&lt;9;i++)&#123; voteManager.vote(&quot;u1&quot;,&quot;abc&quot;); &#125; &#125;&#125; 运行结果如下：恭喜投票成功请不要重复投票请不要重复投票请不要重复投票你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格进入黑名单，将禁止登录和使用本系统","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"https://blog.mmzsblog.cn/categories/DesignPatterns/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.mmzsblog.cn/tags/设计模式/"}]},{"title":"用于mmzsblog网站博客开发","slug":"mmzsblog","date":"2010-10-24T02:24:00.000Z","updated":"2019-02-13T06:40:51.458Z","comments":true,"path":"mmzs/mmzsblog/","link":"","permalink":"https://blog.mmzsblog.cn/mmzs/mmzsblog/","excerpt":"","text":"前提条件提醒以下代码均在系统命令行(非node环境下的命令行)下完成。 cmd打开window系统命令行 直接在mac系统中打开终端 安装nodeJs前往 node官方下载地址下载对应版本进行安装 检测安装状态1$ node -v 出现版本信息则表示安装成功 安装git前往 git官方下载地址下载对应版本进行安装 检测安装状态1$ git --version 出现版本信息则表示安装成功 安装hexo1$ npm install -g hexo-cli 此步骤需要将nodejs安装成功后才可进行，否则将报npm命令不存在的错误 检测安装状态1$ hexo version 出现版本信息则表示安装成功 克隆代码克隆框架代码1$ git clone git@www.mmzsblog.cn:/mmzsblog/blog.git 此步骤需要将git安装成功后才可进行，否则将报git命令不存在的错误。后续在新增文章之前需要先更新框架代码。拉取成功后默认文件夹名称为blog，本篇文章以blog为文件夹名称举例 克隆主题代码12$ cd blog$ git clone git@www.mmzsblog.cn:/mmzsblog/theme.git themes/pure 此步骤需要将git安装成功后才可进行，否则将报git命令不存在的错误，由于框架代码中主题代码不能提交成功，所以将其分开获取。此代码只需要拉取一次，后续新增文章之前可不再更新 安装依赖1$ npm install 执行成功上述操作将出现图中目录文件 开始创建新建文章创建文章之前先更新仓库代码，然后再创建一篇新文章 12$ git pull$ hexo new 你的文章名称 打开当前文件夹下的source/_post目录，找到新建的文件（一般是根据上方新建的文章名称作为文件名称）进行编写 静态图片的处理 放到source/images文件中，在文章中需要进行![](/images/xxx.jpg)的引入 直接放到和文章名称相同的文件夹中，在文章中需要进行![](./xxx.png)的引入 预览文章1$ hexo server 简写 hexo s 打开浏览器输入http://localhost:4000进行访问。如果出现白板且控制台出现了index.html相关的问题则是由于没有获取主题导致的，需要前往克隆主题文件 发布文章由于mmzsblog是通过github进行重定向，所以将不做清理静态文件的操作，避免提交后需要重新设置的重复操作 打包编译12$ git pull$ hexo generate 简写 hexo g 发布提交1$ hexo deploy 简写 hexo d 如果出现以上提示则说明提交成功，隔几分钟后刷新https://blog.mmzsblog.cn即可查看刚刚新增的文章 提交代码提交框架代码，避免多人开发时不同步的问题 1234$ git status$ git add .$ git commit -m &apos;你的说明&apos;$ git push","categories":[{"name":"mmzs","slug":"mmzs","permalink":"https://blog.mmzsblog.cn/categories/mmzs/"}],"tags":[{"name":"mmzs","slug":"mmzs","permalink":"https://blog.mmzsblog.cn/tags/mmzs/"}]}]}